{"meta":{"title":"且听风吟","subtitle":"君子坐而论道，少年起而行之 | stellar.listentothewind.cn","description":"XAOXUU 目前是一个 iOS 开发者，代表作品有：ProHUD、ValueX 等。在业余时间也开发了 Stellar 博客主题，更多的作品可以去项目主页查看，希望大家喜欢～","author":"且听风吟","url":"https://stellar.listentothewind.cn","root":"/"},"pages":[{"title":"关于","date":"2024-03-25T16:10:56.207Z","updated":"2024-03-25T16:10:56.207Z","comments":true,"path":"about/index.html","permalink":"https://stellar.listentothewind.cn/about/","excerpt":"","text":"聆听风的声音，徐徐奏响过往。这里是@且听风吟的山头。人生总是不缺草长莺飞和杨柳依依，一起奏响生命之章吧！关于说说友链 且停亭且听风吟风会吟唱过往传来美好与希望的讯息君亲启"},{"title":"友链","date":"2024-03-25T16:10:56.197Z","updated":"2024-03-25T16:10:56.197Z","comments":true,"path":"friends/index.html","permalink":"https://stellar.listentothewind.cn/friends/","excerpt":"","text":"聆听风的声音，徐徐奏响过往。这里是@且听风吟的山头。人生总是不缺草长莺飞和杨柳依依，一起奏响生命之章吧！关于说说友链 朋友动态朋友文章weekdaycareseeseemexaoxuu 如何自助添加友链？ 先友后链，在我们有一定了解了之后才可以交换友链，除此之外，您的网站还应满足以下条件： 合法的、非营利性、无商业广告 有实质性原创内容的 HTTPS 站点 第一步：新建 Issue新建 GitHub Issue 按照模板格式填写并提交。为了提高图片加载速度，建议优化头像：打开 压缩图 上传自己的头像，将图片尺寸调整到 96px 后下载。将压缩后的图片上传到 去不图床 并使用此图片链接作为头像。第二步：添加友链并等待管理员审核请添加本站到您的友链中，如果您也使用 issue 作为友链源，只需要告知您的友链源仓库即可。1234title: xaoxuuavatar: https://fastly.jsdelivr.net/gh/cdn-x/xaoxuu/avatar/rect-256@2x.pngurl: https://xaoxuu.comscreenshot: https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg待管理员审核通过，添加了 active 标签后，回来刷新即可生效。 如果您需要更新自己的友链，请直接修改 issue 内容，大约 3 分钟内生效，无需等待博客更新。如果无法修改，可以重新创建一个。"},{"title":"便笺","date":"2024-03-25T16:10:56.187Z","updated":"2024-03-25T16:10:56.187Z","comments":true,"path":"notes/index.html","permalink":"https://stellar.listentothewind.cn/notes/","excerpt":"","text":"TOC日常问题解决方案便笺移动端开发笔记前端学习笔记在线工具 持续更新中……"},{"title":"说说","date":"2024-03-25T16:10:56.203Z","updated":"2024-03-25T16:10:56.203Z","comments":true,"path":"talk/index.html","permalink":"https://stellar.listentothewind.cn/talk/","excerpt":"","text":"聆听风的声音，徐徐奏响过往。这里是@且听风吟的山头。人生总是不缺草长莺飞和杨柳依依，一起奏响生命之章吧！关于说说友链"},{"title":"署名-非商业性使用-相同方式共享 4.0 国际","date":"2024-03-25T16:10:58.583Z","updated":"2024-03-25T16:10:58.583Z","comments":false,"path":"page/cc/index.html","permalink":"https://stellar.listentothewind.cn/page/cc/","excerpt":"","text":"This is a human-readable summary of (and not a substitute for) the license. 您可以自由地： 共享 — 在任何媒介以任何形式复制、发行本作品 演绎 — 修改、转换或以本作品为基础进行创作 只要你遵守许可协议条款，许可人就无法收回你的这些权利。 惟须遵守下列条件： 署名 — 您必须给出适当的署名，提供指向本许可协议的链接，同时标明是否（对原始作品）作了修改。您可以用任何合理的方式来署名，但是不得以任何方式暗示许可人为您或您的使用背书。 非商业性使用 — 您不得将本作品用于商业目的。 相同方式共享 — 如果您再混合、转换或者基于本作品进行创作，您必须基于与原先许可协议相同的许可协议分发您贡献的作品。 没有附加限制 — 您不得适用法律术语或者技术措施从而限制其他人做许可协议允许的事情。 声明： 您不必因为公共领域的作品要素而遵守许可协议，或者您的使用被可适用的例外或限制所允许。 不提供担保。许可协议可能不会给与您意图使用的所必须的所有许可。例如，其他权利比如形象权、隐私权或人格权可能限制您如何使用作品。"},{"title":"署名-非商业性使用-相同方式共享 4.0 国际","date":"2024-03-25T16:10:58.583Z","updated":"2024-03-25T16:10:58.583Z","comments":false,"path":"page/cc/license.html","permalink":"https://stellar.listentothewind.cn/page/cc/license.html","excerpt":"","text":"通过行使本协议所授予的权利（定义如下），您接受并同意受到知识共享(Creative Commons)署名—非商业性使用—相同方式共享4.0国际公共许可协议（以下简称“本公共许可协议”）的约束。从合同解释的角度来看，您获得授权的对价是接受本协议的条款，许可人授予您这些权利的对价是可以通过采用本协议条款发布授权作品(material)而获得利益。 第一条 定义 演绎作品(Adapted Material)： 指受到著作权与类似权利保护的，基于授权作品(Licensed Material)而创作的作品(material)，例如对授权作品(Licensed Material)的翻译、改编、编排、改写或其他依据著作权与类似权利需要获得所有人许可的修改。为本公共许可协议之目的，当授权作品(Licensed Material)为音乐作品、表演或录音时，将其依时间序列关系与动态影像配合一致而形成的作品，视为演绎作品(Adapted Material)。 演绎作者的许可： 指您依据本公共许可协议对在演绎作品(Adapted Material)中自己所贡献的部分所享有的著作权与类似权利进行授权的协议。 署名—非商业性使用—相同方式共享兼容协议： 指在 creativecommons.org/compatiblelicenses 上列出且经知识共享组织(Creative Commons)认可、实质上与本公共许可协议相当的协议。 著作权与类似权利： 指著作权和/或与著作权紧密联系的类似权利。类似权利包括但不限于：表演者权、广播组织权、录音录像制作者权、以及数据库特别权利，而不论上述权利的定义和归类如何。为本公共许可协议之目的， 第二条b款第(1)项与第(2)项 所列权利不属于著作权与类似权利。 有效的技术措施： 指根据各司法管辖区遵循《世界知识产权组织版权条约》（1996年12月20日通过）第十一条或类似国际协定项下的义务所制定的法律，在没有适当的授权的情况下，禁止使用者规避的技术措施。 例外与限制： 指合理使用(Fair Dealing and Fair Use)和/或其他适用于您对授权作品(Licensed Material)的使用的著作权与类似权利的例外或限制。 授权要素： 指知识共享公共许可协议(CCPL)名称中所包含的协议特征。本公共许可协议的授权要素包括：署名、非商业性使用和相同方式共享。 授权作品(Licensed Material)： 指许可人通过本公共许可协议授权的文学、艺术作品(artistic or literary work)，数据库或其他作品(material)。 协议所授予的权利： 指依据本公共许可协议的条款和条件所授予您的各项权利，限于适用于您对授权作品(Licensed Material)的使用且许可人有权许可的著作权与类似权利。 许可人： 指通过本公共许可协议进行授权的个人或组织。 非商业性使用： 指该使用的主要意图或者指向并非获取商业优势或金钱报酬。为本公共许可协议之目的，以数字文件共享或类似方式，用授权作品(Licensed Material)交换其他受到著作权与类似权利保护的作品(material)是非商业性使用，只要该交换不涉及金钱报酬的支付。 分享： 指以需要“协议所授予的权利”许可的任何方法或程序向公众提供作品(material)，包括复制、公共展示、公开表演、发行、散布、传播、进口或提供作品(material)给公众以便其能在其选定的时间和地点接收作品(material)。 数据库特别权利： 指除了著作权之外，衍生于1996年3月11日通过的《欧洲议会与欧盟理事会关于数据库法律保护的指令》(Directive 96/9/EC)及其修改或后续版本的权利，或其他国家或地区本质上与之等同的权利。 您： 指依据本公共许可协议行使其所获得授予之权利的个人或机构。 “您的” 有相应的含义。 第二条 授权范围 授权 根据本公共许可协议的条款，许可人授予您在全球范围内，免费的、不可再许可、非独占、不可撤销的许可，以对授权作品(Licensed Material)行使以下“协议所授予的权利”： 复制和分享授权作品(Licensed Material)的全部或部分，仅限于非商业性使用；以及 为非商业目的创作、复制和分享演绎作品(Adapted Material)。 例外和限制 为避免疑义，若著作权的例外和限制适用于您对授权作品(Licensed Material)的使用，本公共许可协议将不适用，您也无须遵守本公共许可协议之条款。 期限 本公共许可协议的期限规定于第六条 a 款。 媒介和形式；允许的技术修改 许可人授权您在任何媒介以任何形式（不论目前已知的或未来出现的）行使本协议授予的权利，并为之进行必要的技术修改。许可人放弃和/或同意不主张任何权利以阻止您为了行使协议项下权利进行必要的技术修改，包括为规避有效技术措施所必须的技术修改。为了本公共许可协议之目的， 基于第二条a款第(4)项 进行的技术修改不构成演绎作品(Adapted Material)。 后续接受者 来自许可人的要约——授权作品(Licensed Material) 本授权作品(Licensed Material)的每一个后续接受者都自动取得许可人的要约，以按照本公共许可协议的条款行使协议授予的权利。 来自许可人的额外要约——演绎作品(Adapted Material) 您基于授权作品(Licensed Material)创作的演绎作品(Adapted Material)的每一个后续接受者都自动取得许可人的要约，以按照您所适用的“演绎作者的许可”协议的条款行使协议所授予的权利。 禁止下游限制 若会限制授权作品(Licensed Material)后续接受者行使本协议所授予的权利，则您不得对授权作品(Licensed Material)提出或增加任何额外的或不同的条款，或使用任何有效技术措施。 并非背书 本公共许可协议不构成、或不得被解释为允许您声明或主张：您或您对授权作品(Licensed Material)的使用与许可人或 第三条a款第(1)项(A)目(i)所规定要求提供署名的权利人相关联，或得到其赞助、同意或被授予正式地位。 其他权利 依据本公共许可协议，著作人身权，例如保护作品完整权、形象权、隐私权或其他类似的人格权利，不在许可范围内。但是，在条件允许的情况下，许可人可以在必要范围内放弃和/或同意不主张其权利，以便您行使本协议所授予的权利。 本公共许可协议不适用于任何专利权或商标权许可。 在自愿的或可放弃的法定或强制许可机制下，许可人在最大可能范围内放弃对您因行使本协议所授予的权利而产生的使用费的权利，不论是直接收取或通过集体管理组织收取。在其他任何情况下（包括授权作品(Licensed Material)被商业性使用的情形），许可人明确保留收取使用费的任何权利。 第三条 授权条件 您行使被许可的权利明确受以下条件限制： 署名 若您分享本授权作品(Licensed Material)（包含修改格式），您必须： 保留如下标识（如果许可人提供授权作品(Licensed Material)的同时提供如下标识）： 以许可人要求的任何合理方式，标识本授权作品(Licensed Material)创作者和其他被指定署名的人的身份（包括指定的笔名）； 著作权声明； 有关本公共许可协议的声明； 有关免责的声明； 在合理可行情况下，本授权作品(Licensed Material)的网址(URI)或超链接； 表明您是否修改本授权作品(Licensed Material)及保留任何先前修改的标记；及 表明授权作品(Licensed Material)依据本公共许可协议授权，并提供本公共许可协议全文，或者本公共许可协议的网址(URI)或超链接。 依据您分享本授权作品(Licensed Material)的媒介、方法及情況，您可以采用任何合理方式满足第三条a款第(1)项的条件 。 例如，提供包含所要求信息来源的网址(URI)或超链接可算是合理地满足此处的条件。 如果许可人要求，您必须在合理可行的范围内移除第三条a款第(1)项(A)目 所要求的任何信息。 相同方式共享 除第三条a款的条件外，如果您分享您创作的演绎作品(Adapted Material)，则下列条件也适用： 您适用的“演绎作者的许可”协议必须是与本许可协议具有相同授权要素的知识共享(Creative Commons)许可协议（可以是本版本或后续版本），或者其他与“署名－非商业性使用－相同方式共享”协议兼容的许可协议。 您必须提供您适用的“演绎作者的许可”协议全文或者该许可协议的网址(URI)或超链接。依据您分享您的演绎作品(Adapted Material)所使用的媒介、方法及情況，您可以采用任何合理方式满足此条件。 您不得提出或施加任何附加或不同的条款或条件、或在演绎作品(Adapted Material)上应用任何有效的技术措施，以限制使用者行使依您所适用的“演绎作者的许可”协议所授予的权利。 第四条 数据库特别权利 当协议所授予的权利包含数据库特别权利，而该数据库特别权利适用于您对授权作品(Licensed Material)的使用时： 为避免疑义， 第二条a款第(1) 项授权您， 仅限于以非商业性目的，摘录、再利用、复制和分享全部或绝大部分数据库资料； 如果您将数据库资料的全部或绝大部分纳入您享有数据库特别权利的另一数据库，则您享有数据库特别权利的该数据库（而非其中的单个内容）视为演绎作品(Adapted Material)，适用第三条b款的要求； 如果您分享全部或大部分该数据库的资料，您必须遵守 第三条a款 规定的条件。 为避免疑义，当协议所授予的权利包含其他著作权与类似权利时，第四条补充且不取代本公共许可协议所规定的您的义务。 第五条 免责声明及责任限制条款 除非许可人另有保证，否则在最大可能范围内，许可人按其现状和现有之基础提供授权作品(Licensed Material)，且没有就授权作品(Licensed Material)做出任何形式的陈述或保证：无论明示、默示、法定或其他形式，包括但不限于任何有关本授权作品(Licensed Material)的权属保证、可交易性、适于特定目的、未侵害他人权利、没有潜在或其他瑕疵、精确性或是否有错误，不管是否已知或可发现。当免责声明全部或部分不被允许时，此免责声明可能不适用于您。 在最大可能范围内， 对于任何因本公共许可协议或使用授权作品(Licensed Material)引起的直接的、特殊的、间接的、附随的、连带的、惩罚性的、警告性的，或其他的损失、成本、费用或损害，许可人不对您负任何法律上或其他的责任（包括但不限于过失责任）。当责任限制部分或全部不被允许时，该限制不适用于您。 前述免责及责任限制声明，应尽可能以最接近于完全排除全部责任的方式解释。 第六条 期限与终止 本公共许可协议在著作权与类似权利存续期间内有效。然而，如果您没有遵守此公共许可协议，则您依据此公共许可协议享有的权利自动终止。 当您使用本授权作品(Licensed Material)的权利根据第六条a款终止时，您的权利在下述情况下恢复： 自违反协议的行为纠正之日起自动恢复，但须在您发现违反情形后30日内纠正；或 根据许可人明示恢复权利的意思表达。 为避免疑义，本公共许可协议 第六条b款 不影响许可人就您违反本公共许可协议的行为寻求法律救济。 为避免疑义，许可人也可在任何时间，以另外的条款或条件提供本授权作品(Licensed Material)，或者停止传播本授权作品(Licensed Material)；然而，许可人此种行为不会终止本公共许可协议。 本协议第一、五、六、七及第八条，不因本公共许可协议终止而失效。 第七条 其他条款和条件 除非明示同意，否则许可人不受您表达的任何附加或不同条款或条件约束。 本公共许可协议未提及的关于授权作品(Licensed Material)之任何安排、共识或协议，不属于且独立于本公共许可协议的条款及条件。 第八条 解释 为避免疑义，本许可协议不会也不应被解释为减少、限制、约束或施加条件于无需本公共许可协议授权即可依法行使的对授权作品(Licensed Material)的任何使用。 在最大可能范围内，如果本公共许可协议的任何条款被视为无法执行，该条款在必要的最小限度内，自动调整至可以执行。如果该条款不能被调整，其应自本公共许可协议中排除适用，不影响其余条款的效力。 除非许可人明示同意，本公共许可协议的任何条款或条件均不得放弃。 本公共许可协议条款不构成、也不得被解释为限制或者放弃适用于许可人或您的特权或豁免，包括豁免于任何司法管辖区或行政机构的法律程序。 知识共享组织(Creative Commons)不是其公共许可协议的一方 。尽管如此，知识共享组织(Creative Commons)可以选择其中一种公共许可协议适用于其发表的作品(material)，在此种情况下被视为许可人。知识共享公共许可协议 (CCPL)的文本属于公共领域，适用CC0公共许可协议。 除用于向公众表明本作品(material)是依照知识共享(Creative Commons)公共许可协议授权，或发布于creativecommons.org/policies的知识共享组织(Creative Commons)政策另有规定允许以外，如未经知识共享组织(Creative Commons)事先书面同意，任何一方均不得使用“知识共享”(Creative Commons)商标和其他相关商标及标识。包括但不限于，将该商标或标识用于对知识共享公共许可协议(CCPL)做出的未经同意的修改，或与授权作品(Licensed Material)使用有关的其他安排、共识或协议。为避免疑义，本段关于商标的限制性规定不构成公共许可协议之一部分。"},{"title":"网站政策","date":"2024-03-25T16:10:58.583Z","updated":"2024-03-25T16:10:58.583Z","comments":false,"path":"page/policy/index.html","permalink":"https://stellar.listentothewind.cn/page/policy/","excerpt":"","text":"本页面所列之内容为 “枋柚梓的猫会发光” 网站（以下简称 “本站”）所采用之著作权规范、评论规则、免责声明、隐私政策。 一、著作权规范 第 1 条 （著作权法律适用）本站所发布内容（包括但不限于文字、图表、照片、音视频、数据、代码等）之著作权，均受包括但不限于以下中华人民共和国法律法规的保护： 《中华人民共和国著作权法》 《信息网络传播权保护条例》 第 2 条 （著作权许可协议）本站作品采用了六种著作权许可协议，转载或引用前请留意文末标注的许可协议。如您认为本站内容侵犯了您的权益，请与本站联系，本站将在核实后及时予以删除。 CC BY-NC-SA 4.0：转载或引用时，需注明出处、且不得用于商业用途，细节要求见许可协议； 禁止转载引用：默认禁止转载引用，如需转载或引用，请先联系作者获得授权； 原作许可协议：作品由他人创作，转载或引用时，请遵守原作之著作权许可协议。 来自互联网：作品来自互联网，未知来源，如有侵权请联系删除。 允许规范转载：转载或引用时，需要注明出处，无其他要求限制。 允许付费转载：转载或引用时，可以联系作者通过付费方式获得授权。 二、评论规则 第 3 条 （评论提交信息）在本站发布评论需要您留下：昵称、邮箱、网站链接（可选），相关信息的隐私处理请查阅本站《隐私政策》。您提交评论即默认接受该评论采用 CC BY-NC-SA 4.0 知识共享许可协议。 第 4 条 （评论管理）发布的评论需要符合以下标准：合法、友善、相关、有益，不符合前述标准的评论将会被直接删除。如您认为您或他人发布的评论不适合展示在本站，请与本站联系，本站将在评估确认后予以删除。 三、免责声明 第 5 条 （个人立场）本站内容仅为个人言论，不代表站长本人所属（或曾经所属）机构的观点。评论区的内容仅代表该评论发布者的观点，不代表本站认同该言论，且不对此内容产生的影响承担责任。 第 6 条 （内容责任）由于本站所发布的内容有其特定背景，而社会环境不断变化，又因获取资料信息限制，本站不对所发布内容之准确性、完整性、可靠性、可用性和及时性做保证。因此，相关读者有义务自行对所有内容在其预期用途中的适用性进行检查。在任何情况下，本站都不对因使用本站内容而造成的或与之有关的任何间接、附带或结果性损失负责或承担责任。 第 7 条 （链接责任）本站所发布的内容包含有外部网站链接，仅为方便读者而设。本站在添加链接时已尽可能检查其是否违反相关法律法规，但是外部网站内容始终由其相关提供者或运营者负责，本站无法控制这些外部网站，因此本站不对其内容承担任何责任。 四、隐私政策 第 8 条 （隐私保护法律适用）本站依照以下中华人民共和国法律的相关规定，收集、存储、使用访客的隐私数据： 《中华人民共和国个人信息保护法》 《中华人民共和国网络安全法》 《中华人民共和国数据安全法》 由于前述的中国法律与欧盟《通用数据保护规则》（GDPR）可能存在冲突，本站不对欧盟用户提供服务。 第 9 条 （信息收集）以下类型的信息可能被收集： 您主动提交给本站的个人信息； 有关您计算机的信息，包括但不限于 IP 地址、浏览器类型和版本以及操作系统类型和版本； 有关您访问和使用本网站的信息，包括但不限于引荐来源、访问日期和时间、页面浏览量以及网站导航路径。 第 10 条 （信息使用）本站可能将您的信息用于以下用途： 为您提供本站的网站服务； 向您发送您指定的电子邮件通知； 确保本站的网站安全和防止欺诈； 其他符合法律规定的合理用途。 未经您的明确同意，本站不会将您的个人信息提供给任何第三方以供其或任何其他第三方用于营销。 第 11 条 （第三方服务）本站提供的服务可能会包含第三方的产品和服务，或包含通往他们的链接。本站无法控制第三方的隐私政策和规则，并且不对此承担任何责任。 本站也可能通过第三方获取由他们收集的您的信息。本站对这些信息的获取和使用将不受本隐私政策限制。然而，第三方能够向本站披露的信息依然会受到他们的隐私政策的限制。 第 12 条 （信息披露）本站不会主动公开披露用户信息，除非出现下列情形之一： 中国的法律法规规定应当公开披露的信息； 与中国的国家安全、重大公共利益有关，或与犯罪侦查、起诉、审判和判决执行等有关，而应中国执法机构要求提供的； 出于维护您或其他个人的生命、财产等重大合法权益但又很难得到本人同意的； 您自行在本站评论区公开的个人信息； 本政策另有特别规定的情况。 五、政策修订 第 13 条 （更新修订）本站保留在任何时间修改、修订或更新本页政策内容的权利。 最后更新日期的变化表示该政策已被更新或编辑，更新或编辑的版本在发布后立即取代先前任何版本。浏览器、运营商、CDN 和其他组织或个人可能出于节省带宽或其他因素缓存本站的页面，在这种情况下导致您看到的页面内容和实际不符，应当以本站提供的为准。 最后更新日期：2022 年 06 月 07 日"},{"title":"开启ios之旅","date":"2024-07-19T17:17:11.306Z","updated":"2024-07-19T17:17:11.306Z","comments":true,"path":"wiki/ios/index.html","permalink":"https://stellar.listentothewind.cn/wiki/ios/","excerpt":"","text":"ios 学习记录"},{"title":"objective-c 基础学习","date":"2024-07-24T15:53:03.990Z","updated":"2024-07-24T15:53:03.990Z","comments":true,"path":"wiki/ios/objective-c_基础学习.html","permalink":"https://stellar.listentothewind.cn/wiki/ios/objective-c_%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0.html","excerpt":"","text":"对C的扩展 Objective-C 程序 123456#import &lt;Foundation/Foundation.h&gt;int main (int argc, char *argv[]) &#123; NSLog (@&quot;Hello, Objective-C!&quot;); return 0;&#125; // main main.m文件，Xcode通过.m来表明文件是Objective-C类型，从而交给Objective-C编译器执行。.m代表的是message，这是Objective-C的一个重要特性。 解构 Objective-C 程序 #import语句 保证头文件只会被引用一次。 NSLog() 和 @“字符串” 字符串打印函数，与C语言中的printf类似，但是在此基础之上添加了一些新的特性： 时间戳 日期戳 自动附加换行符('\\n') NS前缀只是为了避免名称冲突。 @表示引号内的字符串会被作为Cocoa的NSString元素来处理。 布尔类型 不是仅可以存储YES或NO值的真正布尔类型 是对signed char的类型重定义 一个字节，使用#define将YES定义为1，NO定义为0 面向对象编程 小知识 id是一种泛型，可以引用任意类型的对象 [对象 方法]表示调用该对象的方法 相关术语 类：表示对象类型的结构体 对象：包含值和指向其类的隐藏指针的结构体 实例：对象 消息：对象可以执行的动作 方法：响应消息而运行的代码 方法调度：推测执行什么方法以响应某个特定的消息 类的声明 @interface 12345678910111213141516@interface Cicle : NSObject&#123; // 实例变量，对象一旦被创建，都会默认包含所有的实例变量，并且赋予默认值。如果没有实例变量，可以直接省略花括号 ShapeColor fillColor; ShapeRect bounds;&#125;// 方法- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;// 方法调用 中缀符 [对象 方法[:，冒号有无取决于后面有无参数] [参数说明: 要传入的实际参数] [...]]// 栗子：[textThing setStringValue: @&quot;helllo there&quot; color: blue]@end // Cicle @implementation 类方法的真正实现 123456@implementation Cicle- (void) setFillColor: (ShapeColor) c&#123; fillColor = c;&#125; // setFillColor...... @implementation 是编译器指令，用于说明为某个类提供执行的代码 可以定义没有在 @interface 中声明的方法，相当于该类的私有方法。不过Objective-C中并不存在真正的私有方法。 @interface 与 @implementation 中的方法参数可以不同，但是，@implementation 中的方法参数不应与实例变量名相同，防止出现覆盖的情况 继承 语法格式 12@interface 子类 : 父类@end 不支持多继承 需要重写的方法仍然需要在 @implementation 中定义，什么都不写或者返回一个虚值(dummy) 方法调度 对象拥有一个指向类的指针，类拥有一个指向其执行代码的指针和一个指向其父类的指针。当对象去调用一个方法时，首先会通过它的指向类的指针去它父类的代码里面去寻找是否包含该方法，如果不包含，则转去它的父类的父类里面去寻找，以此类推，直到找到对应的方法。如果在顶层父类中仍旧没有找到该方法，则会报错。 实例变量 每个方法调用都会传入一个名 self 的隐藏参数用来指向对象本身 每一个对象都有一个isa指针指向其类对象，每一个类对象也有一个 isa 指针指向其父类对象。顶层父类 NSObject只有一个实例变量— isa 指针，用来指向本身 对象在访问其实例变量的时候，会使用 self 指针从继承链实例变量顶层一次往下寻找，即：从 NSObject 的isa开始往下找 super 关键字 调用父类的方法 复合 通过将实例对象的指针作为当前对象的实例变量来实现 准确来说，是一种对象间的组合 栗子 123456@interface Car : NSObject&#123; Tire *tires[4]; // 此处便是复合 Engine *engine;&#125;@end // Car 此时，Car对象会给实例对象指针分配内存空间，但是并不会给响应的对象分配内存空间 使用 new 创建对象的过程 分配内存空间 调用类的init方法进行初始化 init 方法的简要讲解 代码 1234567@implementation Car- (id) init &#123; if (self = [super init]) &#123; .... &#125;&#125;@end 说明 [super init] 让父类的初始化工作完成 self = [super init] 将返回的已经初始化的对象指针赋予给当前的 self，防止出现父类初始化返回的对象与一开始创建的对象不一致的问题 存取方法 用来存取或者改变对象属性的方法 setter 方法的命名格式是在其所要修改的变量名称前面加 set getter 方法的命名格式是直接将所要读取的变量作为方法名 所有对象间的交互都是通过指针来实现的 复合还是继承 继承： is a 复合： has a 源文件组织 拆分接口与实现 .h 头文件：存放类的 @interface 指令、公共 struct 定义、enum 常量、#define 和 extern 全局变量等 .m 文件：存放所有的实现内容 .mm 文件可以同时使用 C++ 和 Objective-C 编程 .m 文件中使用 @import 导入创建的 .h 文件，若是系统文件，使用尖括号，若是项目中自定义的文件，使用双引号 @class 关键字 前向引用。告诉编译器这是一个类，以后会知道这个类具体的内容。 可以避免 .h 文件中的循环引用问题 注意 如果一个类继承另外一个类，那么，父类就不可以使用 @class 来进行前向引用。因为，编译器要编译子类的时候，需要预先知道其父类的详细信息，从而在其父类的基础之上对子类进行编译。而且，@class 实际上是通过告诉编译器这是一个使用指针来指向对象的变量，所以只需要申请对应的内存空间即可，但是子类继承父类则不是这么回事。故而，我们不可以使用上述方法来引入父类。 Xcode 按键 描述 Control + I 选中代码，点击自动缩进 Command + [ 将选中的代码左移 Command + ] 将选中的代码右移 Command + shift + O open quickly 选中 + option + 点击 打开开发者文档 Tab键 接受代码自动完成提示 Control + . 循环浏览代码提示 shift + Control + . 反向循环浏览代码提示 Command + Comtrol + S 创建快照 Control + F 前移光标 Control + B 后移光标 Control + P 移动光标到上一行 Control + N 移动光标到下一行 Control + A 移动光标到本行行首 Control + E 移动光标带本行行位 Control + T 交换光标左右两边的字符 Control + D 删除光标右边的字符 Control + K 删除本行 Control + L 将光标置于窗口正中央 Command + Control + 向上方向键 打开配套的文件 Command + Y 激活/禁用断点 Command + Control + Y 继续运行（在调试器中有效） F6 跳过 F7 跳入 F8 跳出 command＋option ＋ ⬅️ 局部折叠 command＋option ＋ shift + ⬅️ 全部折叠 Foundation Kit struct 结构体 NSRange 范围 12345typedef struct _NSRange&#123; unsigned int location; unsigned int length;&#125; NSRange; 表示事物的范围。location 表示范围的起始位置，length 表示范围的长度。注意：location 还可以使用 NSNotFound 来表示没有范围 通常用于表示字符串或者数组的范围 创建 NSRange 方式 1234567891011// way 1 NSRange range;range.location = 10;range.length = 10;// way 2NSRange range = &#123;10, 10&#125;;// way 3 该方式可以作为函数参数直接传递NSRange range = NSMakeRange(10, 10); 几何数据类型 由 Core Graphics 框架（由C语言所写）提供，用于进行2D渲染。带有前缀 CG 12345678910111213141516171819// 坐标struct CGPoint&#123; float x; float y;&#125;;// 存储长度和宽度struct CGSize&#123; float width; float height;&#125;;// 矩形struct CGRect&#123; CGPoint origin; CGSize size;&#125;;// 创建这些数据类型的函数：CGPointMake()、CGSizeMake()、CGRectMake() 使用结构体的原因 在 Objective-C 中，对象都是动态分配的，而动态分配会消耗大量的时间。而在程序中，尤其是GUI程序中，存在着大量的临时的坐标、大小和矩形区域的创建和使用。如果将结构体换成对象的话，会大大增加系统的开销。 字符串 NSString 创建字符串 12345678// + (id) stringWithFormat: (NSString *) format, ...;NSString *height;height = [NSString stringWithFormat: @&quot;Your height is %d feet, %d inches&quot;, 5, 11];// 结果// Your height is 5 feet，11 inches stringWidthFormat 方法中的参数列表中的最后一个参数是 ... ，这说明这个方法可以接受多个以逗号隔开的其他参数 类方法 Objective-C 在生成一个类的时候，会创建一个代表该类的类对象（class object）。其包含了指向父类、类名和类方法列表的指针，还包含一个 long 类型的数据，用来给新创建的对象指定大小 在声明方法的时候添加了加号，那么，就声明了一个类方法，该方法属于类对象。这个方法通常会用来创建新的类的实例对象，这种方法被称为工厂方法。 关于大小 length 返回字符串的字符个数 - (NSUInteger) length; 1NSUInteger length = [height length]; 相比于C语言中的 strlen 方法，该方法可以精确地计算各种语言的字符串的字符个数。因为有些字符的字节数可能会大于一个字节，而 strlen 函数只是单纯地返回字节数而导致计算。 字符串比较 1- (BOOL) isEqualToString: (NSString *) aString; 返回一个BOOL值来表示两个字符串是否相同。如果要比较两个字符串是否是同一个，需要使用 == 来直接比较对象指针的地址 1- (NSComparisonResult) compare: (NSString *) aString; 将当前的对象与传递的字符串中的字符进行逐个比较，返回一个 NSComparisonResult (一个 enum 型枚举)来表示最终的比较结果。 区分大小写 12345678enum&#123; NSOrderedAscending = -1, // 左边字符串更小 NSOrderedSame, // 两字符串相同 NSOrderedDescending // 右边字符串相同&#125;;typedef NSInteger NSComparisonResult; 栗子 1234567NSString *thing1 = @&quot;hello 5&quot;;NSString *thing2 = [NSString stringWithFormat: @&quot;hello %d&quot;, 5];if ([thing1 isEqualToString: thing2]) &#123; NSLog(@&quot;They are same!&quot;);&#125; 不区分大小写的比较 1- (NSComparisonResult) compare: (NSString *) aString options: (NSStringCompareOptions) mask; options: 参数是一个掩位码，可以使用位或 | 来添加选项标记。可用的标记如下： NSCaseInsensitiveSearch: 不区分大小写 NSLiteralSearch: 区分大小写 NSNumericSearch: 比较字符串的个数而不是字符串的值 栗子 1234if ([thing1 compare:options: NSCaseInsesitiveSearch | NSNumericSearch] == NSOrderedSame) &#123; NSLog(@&quot;They match!&quot;);&#125; 字符串内是否还包含别的字符串 判断字符串是否以另一个字符串开头 1- (BOOl) hasPrefix: (NSString *) aString; 判断字符串是否以另一个字符串结尾 1- (BOOl) hasSuffix: (NSString *) aString; 判断字符串内部是否包含另一个字符串 1- (NSRange) rangeOfString: (NSString *) aString; 返回一个 NSRange 结构体，说明字符串匹配的部分在哪里以及能够匹配上的字符个数。如果没有匹配，那么结构体里面的 location 值为 NSNotFound 可变性 NSString 是不可变的。不能以删除字符或者添加字符的方式来改变字符串。 注意：NSString 的子类 NSMutableString 可变 创建 NSMutableString 1234- (id) stringWithCapacity: (NSUInteger) capacity;NSMutableString *string = [NSMutableString stringWithCapacity: 47]; 这里的容量只是一个建议值， 可以超过这个大小。 添加字符串 appendString 1- (void) appendString: (NSString *) aString; 将要添加的字符串添加到当前字符串的结尾 appendFormat 1- (void) appendFormat: (NSString *) aString, ...; 并不会创建新的字符串，而是将格式化后的字符串添加到当前字符串的结尾 栗子 123NSMutableString *string = [NSMutableString stringWithCapacity: 47];[string appendString: @&quot;Hello there &quot;];[string appendFormat: @&quot;human %d&quot;, 39]; 删除字符串 deleteCharactersInRange 1- (void) deleteCharactersInRange: (NSRange *) aRange; 集合大家族 NSArray 是一个 Cocoa 类，用来存储任意类型对象的有序列表 只能存储 Objective-C 对象 不能存储 nil 不可变数组 创建 1234// 方式 1NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;, nil];// 方式 2 字面量语法格式 无需添加 nil 来表示数组结束NSArray *array2 = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; 发送一个以逗号分隔的对象列表 列表末尾添加 nil 代表结束，这也是数组无法存储 nil 的原因 内置方法 1234567891011121314// 获取元素数量- (void) count;// 获取某个特定索引处的元素- (id) objectAtIndex: (NSUInteger) index;// 通过字面量获取元素id *myObject = array[1];// 栗子for (NSInteger i = 0; i &lt; [array count]; ++i) &#123; NSLog(@&quot;index %d has %@.&quot;, i, [array objectAtIndex:i]); NSLog(@&quot;index %d has %@.&quot;, i, array[i]);&#125; 异常（exception） 是 Cocoa 说明“我不知道该如何处理”的方式 123456// 切分数组NSString *string = @&quot;oop:ack:bork:greeble:ponies&quot;;NSArray *chunks = [string componentsSeparatedByString:@&quot;:&quot;]; // 根据&quot;:&quot;来切割字符串并返回一个数组string = [chunks componentsJoinedByString:@&quot;-&quot;]; // 根据&quot;-&quot;来连接数据中的字符串并返回最终合成的字符串 可变数组：NSMutableArray 创建 123456+ (id) arrayWithCapacity: (NSUInteger) numItems;// 栗子NSMutableArray *array = [NSMutableArray arrayWithCapacity:17]; 容量只是最终容量的一个参考 没有用来创建 NSMutableArray 的字面量语法 添加元素或删除元素的时候会动态地调整容量大小 添加对象 123456- (void) addObject: (id) anObject;// 栗子for (NSIngeter i = 0; i &lt; 4; ++i) &#123; [array addObject: @&quot;123&quot;];&#125; 在数组末尾添加元素 特定位置删除元素 1234- (void) removeObejectAtIndex: (NSUIngeter) index;// 栗子[array removeObjectAtIndex: 0]; // 删除位置为0的数组元素 删除元素之后，数组后面的所有元素自动向前移动 枚举 NSEnumerator，Cocoa 用它来表示集合中迭代出的对象。需要提前获取数组的枚举器。 123456789101112131415161718- (NSEnumerator *)objectEnumerator; // 从前往后的迭代器// 栗子NSEnumerator *enumerator = [array objectEnumerator];- (NSEnumerator *) reverseObjectEnumerator; // 从后往前的迭代器// 使用枚举器获取下一个对象- (id) nextObject; // 如果返回 nil 表示迭代结束 这也是数组中不能存储 nil 的另外的一个原因// 栗子NSEnumerator *enumerator = [array objectEnumerator];while (id = thingie = [enumerator nextObject]) &#123; NSLog(@&quot;I found %@&quot;, thingie);&#125; 注意：不能在使用迭代器的过程中添加或者删除数组中的元素，否则会导致迭代器混乱，获得未定义的结果 快速枚举 类似于foreach 1234for (NSString *string in array) &#123; NSLog(@&quot;I found %@&quot;, string);&#125; 无法在旧的机器上运行 NSDictionary 不可变 创建 123456// 方式 1 字面量方式@&#123;key:value,...&#125;// 方式 2 函数方式+ (id) dictionaryWithObjectsAndKeys: (id) firstObject,...; dictionaryWithObjectsAndKeys 后面的参数先是value，然后才是key dictionaryWithObjectsAndKeys 以 nil 值作为终止符号，所以，NSDictionary 不能存储 nil 值 字面量语法不需要以 nil 结尾 123456789Tire *t1 = [Tire new];Tire *t2 = [Tire new];Tire *t3 = [Tire new];Tire *t4 = [Tire new];NSDictionary *tires = [NSDictionary dictionaryWithObjectsAndKeys: t1, @&quot;font-left&quot;, t2, @&quot;font-right&quot;, t3, @&quot;back-left&quot;, t4, @&quot;back-right&quot;, nil]; // 先value后key 以nil作为结尾NSDictionary *tires = @&#123;@&quot;font-left&quot;:t1, @&quot;font-right&quot;:t2, @&quot;back-right&quot;:t3, @&quot;back-right&quot;:t4&#125;; 访问 123456// 方式 1 使用函数- (id) objectForKey: (id) aKey;// 方式 2 字面量语法tires[key]; 可变字典 NSMutableDictionary 123456789101112// 创建+ (id) dictionaryWithCapacity: (NSUInteger) numItems;// 直接给 NSMutableDictionary 发送 dictionary 信息[NSMutableDictionary dictionary];// 添加元素 如果存在相同的key 那么会直接覆盖原有的value- (void) setObject: (id) anObject forKey: (id) aKey;// 删除元素- (void) removeObjectForKey: (id) aKey; 不要乱来 不要尝试创建 NSString 、 NSArray、或 NSDictionary 的子类。因为在 Cocoa 中，许多的类都是以类簇的方式来实现的，他们是一群隐藏在通用接口之下的与实际实现相关的类。我们在创建 NSString 对象的时候，实际上可能得到是 NSLiteralString 或者其他类型的类。 其他数值 NSNumber 123456// 函数方法+ (NSNumber *) numberWithChar: (char) value;+ (NSNumber *) numberWithInt: (int) value;+ (NSNumber *) numberWithFloat: (float) value;+ (NSNumber *) numberWithBool: (BOOL) value; 12345678910// 字面量方法NSNumber *number;number = @&#x27;X&#x27;; // 字符型number = @12345; // 整型number = @12345ul; // 无符号长整数number = @12345ll; // long longnumber = @123.45f; // 浮点型number = @123.45; // 双浮点型number = @YES; // 布尔值 1234567// NSNumber --&gt; 基本数据类型- (char) charValue;- (int) intValue;- (float) floatValue;- (BOOL) boolValue;- (NSString *) stringValue; Objective-C 不支持自动装箱功能。 NSValue 可以封装任意值 12// 函数方法+ (NSValue *) valueWithBytes: (const void *) value objcType: (const char *) type; 传递的参数是要封装的数值的地址 objcType 指的是一个描述数据类型的字符串，通常使用 @encode(数据类型) 来获取该字符串 12345678910// 获取数值- (void) getValue: (void *)buffer;// 栗子NSRect rect = NSMakeRect (1, 2, 30, 40);NSValue *value = [NSValue valueWithBytes:&amp;rect objcType:@encode(NSRect)];[array addObject:value];value = [array objectAtIndex:0];[value getValue:&amp;rect]; getValue 中传入的参数是要存储数据所要存储的空间的地址 12345678910111213// 常用的将struct转换成NSValue的方法+ (NSValue *)valueWithPoint: (NSPoint) aPoint;+ (NSValue *)valueWithSize: (NSSize) size;+ (NSValue *)valueWithRect: (NSRect) rect;- (NSPoint) pointValue;- (NSSize) sizeValue;- (NSRect) rectValue;// 栗子value = [NSValue valueWithRect: rect];[array addObject: value];...NSRect anotherRect = [value rectValue]; NSNull 代表什么都没有，用于消除 nil 带来的歧义，并可以作为对象存储到容器中 12345678+ (NSNull *) null; // 总是返回相同的数值 可以使用 == 来与其他的值进行比较// 栗子[contact setObject: [NSNull null] forKey: @&quot;home fax machine&quot;];id homefax = [contact objectForKey: @&quot;home fax machine&quot;];if (homefax == [NSNull null]) &#123; // ...&#125; 内存管理 对象生命周期 诞生（alloc、new） --》 生存（接收消息并执行操作） --》 交友（复合、想方法传递参数） --》 死去 引用计数 每一个对象都会有一个引用计数器与之关联，当其被访问时，引用计数器会加1，访问结束后，引用计数器会减1 当使用 alloc new 或者 copy 创建一个对象时，对象的引用计数器会被设置成1 给对象发送 retain 消息，引用计数器会加1；给对象发送 release 消息，引用计数器会减一 对象的引用计数器减为0时，编译器会自动调用对象的 dealloc 方法来释放资源。我们也可以重写 dealloc 方法 123- (id) retain;- (oneway void) release;- (NEUInteger) retainCount; retain 会返回一个 id 类型的值，从而可以实现对象在引用计数器加1的同时还可以完成其他的动作 自动释放池和销毁时间 创建 @autoreleasepool 关键字 123@autoreleasepool &#123;&#125; NSAutoreleasePool 对象 1234NSAutoreleasePool *pool;pool = [NSAutoreleasePool new];...[pool release]; 优先使用关键字语法 自动释放池的分配和销毁的代价很小 自动释放池以栈的形式实现 垃圾回收 自动内存管理机制 启用垃圾回收机制后，平常的内存管理指令就不起作用了 对象初始化 分配对象 向某个类发送 alloc 消息，可以为该类分配一块足够大的内存空间，用来存放该类的全部实例变量。 同时，alloc 方法还会将这块内存空间全部初始化为0 初始化对象 1234// 正确写法Car *car = [[Car alloc] init];// 错误写法Car *car = [Car alloc]; [Car init]; 如果不使用嵌套，那么会导致初始化方法返回的对象和分配的对象不一致 编写初始化方法 12345678910(id) init &#123; if (self = [super init]) &#123; engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125; // init if (self = [super init]) 的解释：先运行 [super init] 以完成父类自身的初始化操作。这个赋值操作只影响 init 方法中的 self 值，不会影响该方法之外的任何内容 如果在初始化对象时出现问题，那么 init 方法可能会返回 nil，表示没有成功初始化对象 惰性求值：即使目前没有设置自定义属性的值，也应该等到调用者需要时再创建对象 构造初始化方法 1234567891011121314151617181920212223@interface Car: NSObject&#123; ...&#125;- (id) initWithPresure: (float) p treadDepth: (float) td ...@end@implementation Car- (id) initWithPresure: (float) p treadDepth: (float) td &#123; if (self = [super init]) &#123; presure = p; treadDepth = td; &#125; return self;&#125;...@end// 使用Car *car = [[Car alloc] initWithPresue:20 treadDepth:33]; 属性 语法 1@property 类型 属性名 可以通过调用 -set属性名 来设置属性值 可以通过调用 -属性名 来获取属性值 @property 的作用是让编译器自动添加 setter 和 getter 方法 1@synthesize 属性名 创建了该属性的访问代码 Xcode4.5 以后的版本不需要再使用该语法了 变量的声明位置的区别 实例变量如果在 .h 文件中声明，那么，其子类也可以直接通过属性来访问实例变量 实例变量如果在 .m 文件中声明，那么，其子类不可以直接通过属性来访问实例变量 如果我们并没有声明实例变量，那么编译器会自动帮我们创建实例变量 点表达式的妙用 12对象.属性名 = 属性值; // 修改对象.属性名 // 访问 属性扩展 12@property (copy) 属性名; // 属性会被复制@property (assign) 属性名; // 默认是弱引用 如果没有手动指定属性的特性，那么会默认使用 assign 和 nonatomic nonatomic 属性如果不在多线程中使用，可以提高访问方法的调用速度 自己定义了 setter 或 getter 方法，就不可以使用 atomic 特性 名称的使用 属性的名称和实例变量的名称可以不相同 语法 12345678910111213@synthesize 属性名 = 实例变量名// 栗子@interface Car : NSObject&#123; NSString *appellation; ...&#125;@property (copy) NSString *name;@synthesize name = appellation; 编译器仍旧会创建 -setName 和 -name 方法，只不过里面操作的实例变量变为了 appellation 只读属性 1@property (readonly) 属性类型 属性名; @dynamic 告诉编译器不要生成任何代码或者创建相应的实例变量 1@dynamic 属性名称; 类别 一种为现有的类添加新方法的方式 类别代码通常单独放在一个文件中，并且按照“类名+类别名”命名文件 声明 12345678910@interface NSString (NumberConvenience)- (NSNumber *) lenghtAsNumber;@end@implementation NSString (NumberConvenience)- (NSString *) lengthAsNumber &#123; NSUInteger length = [self length]; // 获取字符串的长度 return ([NSNumber numberWithUnsignedInt:length]);&#125;@end 类名后面的括号里面的新名称就是类别的名称 只要保证类别名称唯一，你可以向一个类添加任意数量的类别 可以添加方法但是不能添加实例变量 可以添加属性，但是属性必须是 @dynamic 类型的。好处是你可以通过点来访问 setter 和 getter 方法 **注意：**任何 NSString 对象都可以响应 lengthAsNumber 消息，包括字面量字符串、description 方法返回的字符串、可变字符串、其他工具集部分字符串、文件中加载的字符串、从因特网海量内容中提取的字符串等 类别的局限性 无法添加新的实例变量 名称冲突，类别的优先级高于类中方法的优先级。当类别的方法和类中的方法重名的时候，类别的方法会取代类中的方法，导致类中的方法不再可用。 类别的优势 将类的实现代码分散到不同的文件中 创建对私有方法的前向引用 向对象添加非正式协议 类扩展 特殊的类别 无需类别名 可以在自己的类中使用 可以添加实例变量 可以将只读的权限改为可读可写的权限 创建的数量不限 1234567891011121314@interface Things : NSObject@property (assign) NSInteger things;@property (readonly, assign) NSInteger things;...- (void) resetAllValues;@end@interface Things ()&#123; NSInteger thing4;&#125;@property (readwrite, assign) NSInteger thing2;@property (assign) NSInteger thing3;@end 所添加的都是私有的属性和方法 类别可以访问继承的类的实例变量 Cocoa 并没有真正的私有方法，我们可以直接使用对象支持的却没有在 @interface 中声明的方法，不过会导致编译器警告 通过在类别中声明和实现私有方法来解决 非正式协议和委托类别 委托(delegate)是一种对象，由另一个类请求执行某些工作。 被发送给委托对象的方法可以声明为一个 NSObject 的类别 也就是说，只要实现了委托方法，任何类的对象都可以成为委托对象 创建一个 NSObjct 的类别被称为“创建一个非正式协议” 响应选择器 选择器只是一个方法名称，但是它会以 Objc 运行时使用的特殊方式编码，以快速查询。可以使用 @selector() 圆括号中的方法名称来指定选择器 12345678@selector(setTire:atIndex)// NSObject 使用 respondsToSelector: 来确定是否可以响应某个特定的消息if ([car respondsToSelector:@selector(setEngine)]) &#123; NSLog(@&quot;sdfk&quot;);&#125; 协议 正式协议 包含了方法和属性的有名称列表 使用协议的方式是在类的 @interface 声明中列出协议的名称。采用协议就意味着你必须实现该协议中的所有方法。 声明协议 123@protocol NSCopying- (id) copyWithZone: (NSZone *) zone;@end 协议名称必须唯一 可以继承父协议，后面使用尖括号包裹父协议 123@protocol MySuperDuberProtocol &lt;MyPerentProtocol&gt;@end 协议中不会引入新的实例变量 采用了协议的类必须实现协议中的所有的方法，包括协议继承父协议的方法 采用协议 在类的声明中使用尖括号包裹协议 123456@interface Car : NSObject &lt;NSCopying, NSCoding&gt;&#123;&#125;...@end 一个类只能继承一个直接父类 一个类可以继承多个协议 复制 copy 消息会告诉对象创建一个全新的与接收 copy 消息的对象完全一样的对象 123456789101112@interface Engine : NSObject &lt;NSCopying&gt;@end // Engine@implementation Engine - (id) copyWithZone: (NSZone *) Zone&#123; Engine *engineCopy; engineCopy = [[[self class] allocWithZone: zone] init]; return (engineCopy);&#125;@end [self class] 获取 self 所属的类，这里的 self 指的是正在接收 copy 消息的对象 allocWithZone 是一个类方法，根据类来创建对象的内存空间 Engine 的子类对象也可以被复制 协议和数据类型 可以在使用的数据类型中为实例变量和方法参数指定协议名称。 1- (void) setobjectValue: (id&lt;NSCopying&gt;) object; 传入的参数类型必须遵循 NSCopying 协议 objc 2.0 的新特性 12345678910@protocol BaseballPlayer- (void) drawHugeSallary; // 必须实现的方法@optional // 可选择实现的方法- (void) slideHome;- (void) catchBall;- (void) throwBall;@required // 必须实现的方法- (void) swingBat;@end 委托方法 委托就是一个对象指定另外一个对象处理某些特定任务的设计模式 代码块和并发性 代码块（闭包） 对c语言函数的扩展 由c语言实现 两种绑定类型 自动绑定 使用栈中的内存 托管绑定 使用堆区内存 代码块和函数指针 代码块的特征 返回类型可以手动声明也可以由编译器推导 具有指定类型的参数列表 拥有名称 1234567891011121314// 定义 &lt;returntype&gt; (^blockname) (list of arguments) = ^(arguments) &#123;body;&#125;;void (^my_block)(void); // 无返回值 无参数 有名// 栗子int (^square_block) (int number) = ^(int number) &#123; return number * number;&#125;;int result = square_block(5);...// 如果没有参数，可以省略 `^(arguments)` 括号内容和括号本身void (^theBlock)() = ^&#123;...&#125;; 代码块声明成了变量，可以像函数一样使用 代码块可以替换原先的函数：代码块可以访问与它相同的有效范围内声明的变量，也就是说代码块可以访问与它同时创建的变量 123456int value = 6;int (^multiply_block)(int number) = ^(int number) &#123; return value * number; // 直接使用外部的与代码块在同一话括号内的 value&#125;;int result = multiply_block(7);... 作为参数直接使用代码块 12345NSArray *array = [NSArray arrayWithObjects: @&quot;Amir&quot;, @&quot;Mishal&quot;, @&quot;Irrum&quot;, nil];NSLog(@&quot;Unsorted Array %@&quot;, array);NSArray *sortedArray = [array sortedArrayUsingComparator:^(NSString *object1, NSString *object2)&#123; return [object1 compare: object2];&#125;]; 使用 typedef 关键字 123456typedef double (^MKSampleMutiply2BlockRef) (double c, double d);MKSampleMutiply2BlockRef mutiply2 = ^(double c, double d) &#123; return c * d;&#125;; 代码块和变量 代码块被声明后会捕捉创建点时的状态。代码块可以访问函数用到的标准类型的变量： 全局变量 全局函数 封闭范围内的参数 函数级别的 __block 变量。 用于修饰在代码块中可被修改的变量 不可被声明为 __block 的类型 长度不可变的数组 不包含长度可变数组的结构体 封闭范围内的非静态变量会被捕获为常量 objc的实例变量 代码块内部的本地变量 并发性 能够在同一时间执行多项任务的程序称为并发程序 1234@synchronized (theObject)&#123;&#125; 可以确保不同的线程会连续地访问临界区的代码 如果属性没有指定 nonatomic 特性，那么生成的 getter 和 setter 是彼此互斥的 选择性能 让一些代码在后台执行 创建在线程执行的方法 12- (void) myMethod;- (void) myMethod:(id)myObject; 不能有返回值 要么没有参数，要么只有一个参数 需要在方法中创建自动释放池 12345678- (void) myBackgroundMethod &#123; @autoreleasepool &#123; NSLog(@&quot;My Background Method&quot;); &#125;&#125;// 执行[self performSelectorInBackground:@selector(myBackgroundMethod) withObject:nil]; 当方法执行结束之后，objc 运行时会特定地清理并弃掉线程 调度队列 连续队列：根据指派的顺序执行任务 并发队列：并发执行一个或者多个任务，也是按照指派的顺序来执行任务 主队列：应用程序中有效的主队列，执行的是应用程序的主线程任务 连续队列 12dispatch_queue_t my_serial_queue;my_serial_queue = dispatch_queue_create(&quot;com.apress.MySerialQueue1&quot;, NULL); 第一个参数是队列名称，第二个参数是负责提供给队列的特性 并发队列 运行可以并行执行的任务 一次所运行的任务数是不确定的 三种并发队列 高优先级 默认优先级 低优先级 12dispatch_queue_t myQueue;myQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT， 0)； // 默认优先级 主队列 1dispatch_queue_t main_queue = dispatch_get_current_queue(void); 通常要以同步方式使用该队列，防止出现阻塞主应用程序运行 队列也要内存管理 调度队列也是引用计数对象，可以使用 dispatch_remain 和 dispatch_release 来修改引用计数器的值 只能对自己创建的队列使用上述方法，不能用自全局调度队列上 队列的上下文 可以给调度对象指派全局数据上下文 可以在数据上下文中指派任意类型的数据 上下文的内存管理需要自己做 1234NSMutableDictionary *myContext = [[NSMutableDictionary alloc] initWithCapacity:5];[myContent setObject:@&quot;My Context&quot; forKey:@&quot;title&quot;];[myContent setObject:[NSNumber numberWithInt:0] forKey:@&quot;value&quot;];dispatch_set_context(_serial_queue, (__bridge_retained void*)myContext); 使用字典来存储上下文 需要保证对象是有效的，所以使用 __bridge_retained 来给 myContext 的引用计数器加1 清理函数 对象在弃用之前调用的函数 123456789// 格式void function_name (void *context);// 栗子void myFinalizerFunction(void *contect) &#123; NSLog(@&quot;myFinalizerFunction&quot;); NSMutableDictionary *theData = (__bridge_transfer NSMutableDictionary*)contex; [theData removeAllObjects];&#125; __bridge_transfer 把对象的内存管理由全局释放池变成函数 获取上下文 1NSMutableDictionary *myContext = (__bridge NSMutableDictionary *) dispatch_get_context(dispatch_get_current_queue()); 添加 __bridge 是为了告诉 ARC 我们自己不想管理内存，交由系统来进行管理 添加任务 同步：一直等待前面的任务结束 异步：不必等待任务，会立即返回。优先使用这种方式 调度程序 最简单的方法是通过代码块 代码块必须是 dispatch_block_t 类型 没有返回值 没有参数 1typedef void (^dispatch_block_t) (void) 使用代码块对象 1234dispatch_block_t myBlcok = ^&#123; NSLog(@&quot;My Predfriend block&quot;);&#125;;dispatch_async(_serial_queue, myBlock); 使用函数 1234void myDispatchFunction(void *argument) &#123; ...&#125;dispatch_async_f(_serial_queue, (__bridge void *)[NSNumber numberWithInt:3], (dispatch_function_t)myDispatchFunction); 其他 12dispatch_suspend(_serial_queue); // 暂停dispatch_resume(_serial_queue); // 唤醒 操作队列 创建调用操作 NSInvocationOperation 会给执行任务的类调用选择器 12345678@implementation MyCustomClass- (NSOperation *) operationWithData:(id) data &#123; return [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myWorkerMethod:) object:data];&#125;- (void) myWorkerMethod: (id)data &#123; NSLog(@&quot;My Worker Method %@&quot;, data);&#125;@end 创建代码块操作 123456NSBlockOperation *blockOperation = [NSBlockOperation blockOperationWithBlock:^&#123; // work&#125;];[blockOperation addExecutionBlock:^&#123; // work&#125;]; 向队列中添加操作 NSOperationQueue 一般会并发执行。并且具有相关性，如果此操作是在别的操作的基础之上进行的，那么，这两个操作会相应地执行 可以通过设置最大并发数为1来确保操作是连续执行的 123456789NSOperationQueue *currentQueue = [NSOperationQueue currentQueue]; // 当前队列NSOperationQueue *mainQueue = [NSOperationQueue mainQueue]; // 主队列NSOperationQueue *_operationQueue = [[NSOperationQueue alloc] init]; // 自建队列[theQueue addOperation:blockOperation]; // 添加操作[theQueue addOperationWithBlock:^&#123; NSLog(@&quot;My Block&quot;);&#125;]; 文件加载与保存 属性列表 用来放置一些 Cocoa 可以处理（主要是存储到文件和从文件中加载）的对象 属性列表类 NSArray NSDictionary NSString NSNumber NSDate NSData 上述类的可修改形态(Mutable) NSDate 用于处理时间和日期的基础类 12NSDate *date = [NSdate date]; // 获取当前的时间NSLog(@&quot;today is %@&quot;, date); 123// 与当前时间相隔一段时差的日期NSDate *yesterday = [NSDate dateWithTimeIntervalSinceNow: -(24 * 60 * 60)];NSLog(@&quot;yesterday is %@&quot;, yesterday); +dateWithTimeIntervalSinceNow 接收一个 NSTimeInterval 类型的参数 参数是一个双精度值 以秒为单位 正数表示未来，负数表示过去 NSData 包含大量的字节 可以获取数据的长度 可以获取指向字节起始位置的指针 不可变更。如果需要变更，使用 NSMutableData 即可 1234const char *string = &quot;Hi there, this is a C string!&quot;;NSData *data = [NSData dataWithBytes:string length:strlen(string) + 1];NSLog(@&quot;data is %@&quot;, data);NSLog(@&quot;%d byte string is &#x27;%s&#x27;&quot;, [data length], [data bytes]); length 之所以加1是为了将c语言末尾的 ‘/0’ 包含进去 -length 方法返回字节数量 -bytes 返回字符串起始位置的指针 写入和读取属性列表 集合型属性列表类（ NSArray 和 NSDictionary ）具有一个 -writeToFile:atomically 方法 将属性列表的内容写入文件 NSString 和 NSData 也具有该方法，但是只能写出字符串或数据块 12[[NSArray arrayWithObjects:@&quot;I&quot;, @&quot;seem&quot;, @&quot;to&quot;, @&quot;be&quot;, @&quot;a&quot;, @&quot;verb&quot;, nil] writeToFile:@&quot;./tmp/verbiage.txt&quot; atomically:YES];NSLog(@&quot;%@&quot;, [NSArray arrayWithContentsOfFile:@&quot;./tmp/verbiage.txt&quot;]); atomically 表示是否将文件内容暂存到临时文件中。如果在保存过程中出现意外，那么不会破坏源文件。但是代价是会使用双倍的磁盘空间 缺点是不会返回任何错误信息 修改对象类型 遍历集合并修改对象类型保存 使用 NSPropertyListSerialization 类 123// 预设了很多行为选项propertyListFromData:mutabilityOption:format:errorDescription:// 返回 plist 并且在出现异常的时候会提供错误信息 编码对象 将对象转换成某种格式并保存到磁盘中的机制 对象可以将它们的实例变量和其他数据编码为数据块，然后保存到磁盘中 这些数据块以后还可以重新读回内存，并且基于保存的数据创建新对象 过程叫做编码和解码，或者序列化和反序列化 1234@protocol NSCoding- (void) encodeWithCoder: (NSCoder *) encoder;- (id) initWithCoder: (NSCoder *) decoder;@end 通过 encodeWithCoder 序列化自身 通过 initWithCoder 加载自身 12345678910111213141516- (void) encoderWithCoder: (NSCoder *) coder &#123; [coder encodeObject: name forKey: @&quot;name&quot;]; [coder encodeInt: magicNumber forKey: @&quot;magicNumber&quot;]; [coder encodeFloat: shoeSize forKey: @&quot;shoeSize&quot;]; [coder encodeObject: subThingies forKey: @&quot;subThingies&quot;];&#125;- (id) initWithCoder: (NSCoder *) decoder &#123; if (self = [super init]) &#123; self.name = [decoder decodeObjectForKey: @&quot;name&quot;]; self.magicNumber = [decoder decodeIntForKey: @&quot;magicNumber&quot;]; self.shoeSize = [decoder decodeFloatForKey: @&quot;shoeSize&quot;]; self.subThingies = [decoder decodeObjectForKey: @&quot;subThingies&quot;]; &#125;&#125; 是否使用 super init 取决于父类是否采用了 NSCoding 协议。 没有：super init 有：super initWithCoder 数组被编码时，里面的所有对象均会被编码 会智能地解决循环问题——数组中包含指向该数组的指针变量 键/值编码 一种间接更改对象状态的方式 KVC 简介 valueForKey: 方法 给对象发送消息并传递属性名称参数，获取其属性 NSString *name = [car valueForKey:@&quot;name&quot;]; 先去寻找与参数名称相同的 getter 方法，没找到会接着寻找与参数名称相同的实例变量 通过元数据打开对象进入其中寻找所需要的信息，无需通过对象指针来访问实例变量 会自动装箱和拆箱 setValue:forKey: 方法 设置对象实例变量的值 第一个参数必须是对象指针 其余与 valueForKey: 中的说明相同 键路径 键/值编码还支持指定路径，就像文件系统路径一样，可以遵循一系列关系来指定该路径 假设类 Engine 的实例变量 horsepower 没有设置为属性，也没有提供 getter 方法 和 setter 方法 12[car setValue: [NSNumber numberWithInt:10] forKey: @&quot;engine.horsepower&quot;];NSLog(@&quot;horsepower is %@&quot;, [car valueforKey: @&quot;engine.horsepower&quot;]); 整体操作 如果使用某个键值来访问一个 NSSrray 数组，它实际上会查询响应数组中的每一个对象，然后将查询结果打包到另一个数组中返回 1234NSArray *presures = [car valueForKey:@&quot;tires.presure&quot;];NSLog(@&quot;presures %@&quot;, presures);// 返回到是一个 presure 变量封装称 NSNumber 对象所构成的数组 不能在键路径索引数组，比如：tires[0].presure 快速运算 可以引用一些运算符来进行一些运算 12NSNumber *count;count = [garage valueForKeyPath: @&quot;cars.@count&quot;]; cars 用来获取 garage 对象的属性 @count 用来告诉 KVC 机制计算键路径上的左侧的对象总数 @sum 计算总和 @avg 计算平均值 @min 计算最小值 @max 计算最大值 @distinctUnionOfObjects 获取左侧集合对应右侧属性的集合，这个集合中没有重复的元素 不要滥用 KVC KVC 需要解析字符串，速度比较慢 无法进行错误检查，可能会出现键路径错误 批处理 dictionaryWithValuesForKeys: 传入的字符串数组中的每一个字符串作为 key ，对象中每一个属性名为 key 的 属性名的值作为 value ，然后凭此生成一个字典 123car = [[garage valueForKeyPath:@&quot;cars&quot;] lastObject];NSArray *keys = [NSArray arrayWithObjects: @&quot;make&quot;, @&quot;model&quot;, @&quot;modelYear&quot;, nil];NSDictionary *carValues = [car dictionaryWithValuesForKeys: keys]; setValuesForKeysWithDictionary: 获取字典值并根据 key 设置对象与 key 对应的的属性的值 12345678NSDictionary *newValues = [ NSDictionary dictionaryWithObjectsAndKeys: @&quot;Chevy&quot;, @&quot;make&quot;, @&quot;Nova&quot;, @&quot;model&quot;, [NSNumber numberWithInt: 1964], @&quot;modelYear&quot;, mil];[car setValuesForKeysWithDictionary: newValues]; nil 仍然可用 重写 setNilValueForKey: 方法以提供逻辑上有意义的任何值 1234567- (void) setNilValueForKey: (NSString *) key &#123; if ([key isEqualToString: @&quot;mileage&quot;]) &#123; mileage = 0; &#125; else &#123; [super setNilValueForKey: key]; &#125;&#125; 处理未定义的键 通过重写 valueForUndefinedKey: 方法来处理未定义的键 如果要更改未知键的值，可以使用 setValue:forUndefinedKey: 方法 12345678910111213141516171819@interface Garage: NSObject&#123; NSString *name; NSMutableArray *cars; NSMutableDictionary *stuff;&#125;- (void) setValue: (id) value forUndefinedKey: (NSString *) key &#123; if (stuff == nil) &#123; stuff = [[NSMutableDictionary alloc] init]; &#125; [stuff setValue:value forKey:key];&#125;- (id) valueForUndefinedKey: (NSString *) key &#123; id value = [stuff valueForKey: key]; return value;&#125; 使用静态分析器 无需运行程序便可以从逻辑上检测代码的工具 可以分析出的错误 安全问题，内存泄漏、缓冲区溢出等 并发性问题 逻辑问题 缺点 需要耗费时间进行分析，会拖慢构建程序设计的过程 有时会误报错误 改变了熟悉的工作流程 NSPredicate 用于指定过滤器的条件 创建谓词 创建许多对象，并将其组合起来 查询代码中的字符串 1NSPredicate *predicate = [NSPredicate predicateWithFormat: @&quot;name == &#x27;Herbie&#x27;&quot;]; 谓词字符串左侧的 name 是键路径 谓词字符串右侧的 'Herbie' 是字符串字面量 计算谓词 12BOOL match = [predicate evaluateWithObject: car];NSLog(@&quot;%s&quot;, (match) ? &quot;YES&quot; : &quot;NO&quot;); evaluateWithObjectt: 计算对象是否符合谓词 数组过滤器 12NSArray *array = [cars filteredArrayUsingPredicate: predicate];NSLog(@&quot;%@&quot;, array); filteredArrayUsingPredicate: 是 NSArray 数组中的一种类别方法，会循环过滤数组内容，根据谓词计算每一个对象的值，并将值为 YES 的对象累计到将被返回的数组中 NSMutableArray 可以使用 filteredUsingPredicate 方法 格式说明符 方式一 12predicate = [NSPredicate predicateWithFormat: @&quot;engine.horsepower &gt; %d&quot;, 50];predicate = [NSPredicate predicateWithFormat: @&quot;%K == %@&quot;, @&quot;name&quot;, @&quot;Herbie&quot;]; 方式二 123NSPredicate *predicateTemplate = [NSPredicate predicateWithFormat: @&quot;name == $NAME&quot;];NSDictionary *varDict = [NSDictionary dictionaryWithObjctsAndKeys: @&quot;Herbie&quot;, @&quot;name&quot;, nil];NSPredicate *predicate = [predicateTemplate predicateWithSubstitutionVariables: varDict]; 不能使用 $变量名 来作为键路径 谓词机制不会进行静态类型检查 运算法 1234567891011121314151617// 比较和逻辑运算符&gt; &gt;= &lt; &lt;= !=and or not // 不区分大小写&amp;&amp; || !// 数组运算符between &#123;&#125;in &#123;&#125;// self 表示用于响应谓词计算的对象self.属性名self// 字符串运算法// 接收 [cd] 修饰符 表示 是否区分大小写和发音符beginswith // 以。。。开头endswith // 以。。。结尾contains // 包含。。。// likelike ‘正则表达式’"},{"title":"探索个性化配置","date":"2024-03-25T16:10:58.793Z","updated":"2024-03-25T16:10:58.793Z","comments":true,"path":"wiki/stellar/advanced-settings.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/advanced-settings.html","excerpt":"","text":"主题色 支持 HEX &amp; HSL 表示颜色 blog/_config.stellar.yml1234567891011121314style: ... color: # 动态颜色（会根据明暗主题重设明度值，只用关心色相和饱和度即可） background: &#x27;hsl(212 16% 98%)&#x27; # 浅色背景颜色 block: &#x27;hsl(212 8% 95%)&#x27; # 块背景颜色 code: &#x27;hsl(14 100% 48%)&#x27; # 行内代码颜色 text: &#x27;hsl(0 0% 20%)&#x27; # 文本颜色 # 主题色配置（不会根据明暗动态调整，请设置为通用的颜色） theme: &#x27;hsl(192 98% 55%)&#x27; # 主题色 accent: &#x27;hsl(14 100% 57%)&#x27; # 强调色 link: &#x27;hsl(207 90% 54%)&#x27; # 超链接颜色 button: &#x27;hsl(192 98% 55%)&#x27; # 按钮颜色 hover: &#x27;hsl(14 100% 57%)&#x27; # 按钮高亮颜色 字体 系统字体 blog/_config.stellar.yml1234567891011style: font-size: root: 16px body: .9375rem # 15px code: 85% # 14px codeblock: 0.8125rem # 13px font-family: logo: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; body: &#x27;system-ui, &quot;Microsoft Yahei&quot;, &quot;Segoe UI&quot;, -apple-system, Roboto, Ubuntu, &quot;Helvetica Neue&quot;, Arial, &quot;WenQuanYi Micro Hei&quot;, sans-serif&#x27; code: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; codeblock: &#x27;Menlo, Monaco, Consolas, system-ui, &quot;Courier New&quot;, monospace, sans-serif&#x27; 外部字体 要想引用外部字体，你需要先在 _config.yml 中 inject 引入 举例，引用 Noto Serif SC 在 _config.yml 中写入 blog/_config.yml1234inject: head: - &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Noto+Serif+SC&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt; script: 并在 _config.stellar.yml 中填写你引入的字体名称 blog/_config.stellar.yml123style: font-family: body: &#x27;&quot;Noto Serif SC&quot;, &quot;Microsoft Yahei&quot;,..., sans-serif&#x27; 选择在线字体： https://www.googlefonts.cn/https://www.googlefonts.cn/ 本地字体 若您想引用本地字体，举例，引用得意黑（SmileySans-Oblique.ttf）这个字体，先将字体放置于 blog/source/font/ 目录下，然后改动一下主题文件 Blog/themes/stellar/source/css/_custom.styl12345@font-face font-family: &#x27;Smiley Sans&#x27; src: url(&#x27;/font/SmileySans-Oblique.ttf&#x27;) font-weight: normal font-style: normal font-family 是你引入的字体家族名，src 中填写字体文件相对于 source 文件夹的路径 同样，你需要在 _config.stellar.yml 中填写你引入的字体名称（font-family） blog/_config.stellar.yml123style: font-family: body: &#x27;&quot;Smiley Sans&quot;, &quot;Microsoft Yahei&quot;,..., sans-serif&#x27; 但是我个人并不推荐引用本地字体，相比于英文字体，中文字体囊括了众多的字符，这也无法避免地导致字体文件体积的增加，拿 Noto Serif SC 来说，单个ttf文件就有9mb之大，这对于您的站点而言加载速度可想而知。 文本对齐方向 blog/_config.stellar.yml123style: ... text-align: left # justify/left/center/right 圆角大小 这个功能在 1.18.1 版本后开始支持。 blog/_config.stellar.yml1234567style: ... border-radius: card: 12px # 卡片圆角 block: 12px # 块圆角 bar: 6px # 导航栏圆角 image: 6px # 图片圆角 页面缓入效果 blog/_config.stellar.yml12345678# 默认关闭scrollreveal: enable: false js: https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js distance: 4px # 执行距离 duration: 400 # ms # 执行时长 interval: 100 # ms # 执行间隔（时间） scale: 0.1 # 0.1~1 # 执行方式（缩放） 此效果会和图片懒加载插件冲突，导致部分卡片和footer可能加载不出来 图片懒加载 blog/_config.stellar.yml12345# 默认打开lazyload: enable: true # [hexo clean &amp;&amp; hexo s] is required after changing this value. js: https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.3.1/dist/lazyload.min.js transition: blur # blur, fade 加载提示 加载动态时间线、动态友链等显示提示 blog/_config.stellar.yml1234# 默认打开loading: loading: 正在加载 error: 加载失败，请稍后重试。 渐变色 这个功能在 1.18.2 版本后开始支持。 您可以在搜索框与 wiki 项目的封面开始按钮处设置渐变色 CSS 代码 blog/_config.stellar.yml12345style: ... gradient: # https://webgradients.com/ start: &#x27;linear-gradient(to right, #92fe9d 0%, #00c9ff 50%, #92fe9d 100%)&#x27; search: &#x27;linear-gradient(to right, #04F3FF, #08FFC6, #DDF730, #FFBD19, #FF1FE0, #C418FF, #04F3FF)&#x27; 您可以在下面网站中寻找中意的渐变色 https://webgradients.com/https://webgradients.com/ 当然，如果只想设置纯色的话可以直接设置单色，支持 HEX 和 HSL，例如 search: 'hsl(212 16% 98%)' 顶部检索栏 这个功能在 1.13.0 版本后开始支持。 blog/_config.stellar.yml123######## Index ########post-index: # 近期发布 分类 标签 归档 and ... &#x27;朋友文章&#x27;: /friends/rss/ # 这里填写的链接要与对应页面一致，否则可能无法正确高亮 站点地图 页面底部的站点导航，你也可以在 content 中自定义一些文字信息，支持 Markdown 格式。 123456789101112131415161718sitemap: &#x27;博客&#x27;: - &#x27;[近期](/)&#x27; - &#x27;[分类](/categories/)&#x27; - &#x27;[标签](/tags/)&#x27; - &#x27;[归档](/archives/)&#x27; &#x27;项目&#x27;:# - &#x27;[开源库](/)&#x27; &#x27;社交&#x27;:# - &#x27;[友链](/)&#x27;# - &#x27;[留言板](/)&#x27; &#x27;更多&#x27;:# - &#x27;[关于本站](/)&#x27;# - &#x27;[GitHub](/)&#x27;content: | # 支持 Markdown 格式 本站由 [@anonymity](/) 使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar) 主题创建。 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。# 主题用户越多，开发者维护和更新的积极性就越高，如果您喜欢本主题，请在适当的位置显示主题信息和仓库链接以表支持。 自定义样式 如果要修改样式，您需要删掉主题的样式文件的 CDN 链接，使用本地文件，然后在 themes/stellar/source/css/_custom.styl 中进行修改。 使用其它 highlight.js 代码高亮主题 Hexo 官方有文档：https://hexo.io/docs/syntax-highlight.html#hljs Tip: When line_number is set to false, wrap is set to false and hljs is set to true, you can then use highlight.js theme directly in your site. 以 atom-one-dark 主题为例，翻译过来就是 _config.yml 找到 highlight 并修改为： 1234567highlight: enable: true line_number: false auto_detect: false tab_replace: &#x27; &#x27; wrap: false hljs: true 然后再找到 inject 新增一个 css 链接： 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.5.0/build/styles/atom-one-dark.min.css&quot;&gt; 外部文件注入 在站点根目录下的配置文件中进行修改 inject.head 以在 &lt;head&gt; 标签末尾处注入代码，修改 inject.script 以在 &lt;body&gt; 标签末尾处注入代码。 blog/_config.yml1234567inject: head: - &lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#2d89ef&quot;&gt; - &lt;meta name=&quot;msapplication-config&quot; content=&quot;/assets/favicon/browserconfig.xml&quot;&gt; - &lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&gt; script: - https://gcore.jsdelivr.net/npm/jquery@3.5/dist/jquery.min.js"},{"title":"探索号专题教程分享","date":"2024-03-25T16:10:58.796Z","updated":"2024-03-25T16:10:58.796Z","comments":true,"path":"wiki/stellar/articles.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/articles.html","excerpt":"","text":"小提示如果您也有与 Stellar 相关的文章并希望显示在这里，可以直接在 hexo-theme-stellar 中选择【文章分享】模板按照格式提交即可，立即生效。"},{"title":"评论插件配置（6个）","date":"2024-03-25T16:10:58.800Z","updated":"2024-03-25T16:10:58.800Z","comments":true,"path":"wiki/stellar/comments.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/comments.html","excerpt":"","text":"Beaudar Beaudar 是 Utterances 的中文版本，相比 Utterances 有更多的体验优化，可以按时间倒序排序。 blog/_config.stellar.yml1234comments: service: beaudar beaudar: repo: xaoxuu/blog-comments Beaudar 的配置方法很简单，创建一个仓库，在仓库中创建一个 域名白名单文件，然后在 此处 授权安装即可。 utterances A lightweight comments widget built on GitHub issues. Use GitHub issues for blog comments, wiki pages and more! blog/_config.stellar.yml1234comments: service: utterances utterances: repo: xaoxuu/blog-comments utterances 的配置方法很简单，创建一个仓库，在仓库中创建一个 域名白名单文件，然后在 此处 授权安装即可。 giscus giscus 是由 GitHub Discussions 驱动的评论系统。让访客借助 GitHub 在你的网站上留下评论和反应吧！本项目受 utterances 强烈启发。 blog/_config.stellar.yml123456789101112131415161718comments: service: giscus # giscus # https://giscus.app/zh-CN giscus: data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: lazy crossorigin: anonymous Twikoo blog/_config.stellar.yml1234comments: service: twikoo twikoo: envId: https://xxx # vercel函数 https://twikoo.js.orghttps://twikoo.js.org Waline blog/_config.stellar.yml1234567891011121314151617181920212223242526comments: service: waline waline: js: https://unpkg.com/@waline/client@v2/dist/waline.js css: https://unpkg.com/@waline/client@v2/dist/waline.css # Waline server address url, you should set this to your own link serverURL: https://xxx # waline 地址 # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom locales locale: placeholder: # 输入框内提示文字 # Custom emoji emoji: - https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji https://waline.js.orghttps://waline.js.org Artalk blog/_config.stellar.yml12345678910comments: service: artalk # Artalk # https://artalk.js.org/ artalk: css: https://unpkg.com/artalk@2.4.3/dist/Artalk.css js: https://unpkg.com/artalk@2.4.3/dist/Artalk.js server: # 后端服务地址 placeholder: &#x27;&#x27; darkMode: auto https://artalk.js.orghttps://artalk.js.org 评论的灵活用法 共用评论数据 如果您有多个页面需要共用评论数据，可以在 front-matter 中覆盖评论参数，例如： blog/source/about/index.md123title: 关于beaudar: &#x27;issue-term&#x27;: &#x27;留言板&#x27; blog/source/friends/index.md123title: 友链beaudar: &#x27;issue-term&#x27;: &#x27;留言板&#x27; 使用其它评论数据 如果您有多个页面需要另外一个数据库的评论数据，以 Beaudar 为例，您可以这样： blog/source/wiki/stellar/index.md12345title: 快速开始您的博客之旅giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226"},{"title":"开发者和社区支持","date":"2024-03-25T16:10:58.796Z","updated":"2024-03-25T16:10:58.796Z","comments":true,"path":"wiki/stellar/contributors.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/contributors.html","excerpt":"","text":"开发者点赞支持者1-100 101-200 201-300 301-400 如何加入社区 社区建设主要包括以下几个方面： Issues 技术问题答疑、BUG反馈 Discussions 论坛、相关话题讨论 文档 维护 探索号 文章收录 QQ群：1146399464，验证码：vlts-2021（以聊天为主，技术问题未必跟进。） 无论在什么渠道，学习并掌握 提问的智慧(24k Stars) 可以方便大家更高效地帮你解决问题。 错误的提问XXX 功能怎么用？（文档有详细描述）这个功能怎么用不了啊（不说明自己操作了什么，也不展示实际效果）我怎么跑不起来，能帮我看看吗？（什么也不尝试，直接丢项目代码）怎么报错了呢？（不贴或只贴极少部分的出错提示）这个代码怎么改（扔过来一大段代码）XXX 什么意思？（没有经过任何搜索）正确的提问我这里遇到了一个问题：【问题描述】，我经过了以下尝试：【思路细节】，不能得到解决，报错如下：【报错截图/线上预览地址/仓库源代码地址】，请问该怎么解决？我不太理解【某处】里的【某处】，我的理解是这样的：【思路细节】，对吗？我查看了文档的【某处】，并尝试【做法】，但是没有得到【预想效果】，正确的做法应该是什么？"},{"title":"使用 Stellar 主题的博客","date":"2024-05-04T12:15:08.660Z","updated":"2024-05-04T12:15:08.660Z","comments":true,"path":"wiki/stellar/examples.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/examples.html","excerpt":"","text":"小提示如果您也使用了 Stellar 并希望显示在这里，可以在 hexo-theme-stellar-examples 中提交 issue 告知您的站点信息，在您提交后的大约 3 分钟内生效。"},{"title":"使用「友链朋友圈」极简版","date":"2024-03-25T16:10:58.783Z","updated":"2024-03-25T16:10:58.783Z","comments":true,"path":"wiki/stellar/fcircle.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/fcircle.html","excerpt":"","text":"特别感谢主题内置版本数据服务由 友链朋友圈 极简版提供。这个功能在 1.13.0 版本后开始支持。 第一步：fork repofork @Rock-Candy-Tea/hexo-circle-of-friends第二步：设置自己的友链页面地址和主题类型修改 hexo_circle_of_friends/fc_settings.yaml 文件：1- &#123;link: &quot;https://xaoxuu.com/friends/&quot;, theme: &quot;stellar&quot;&#125; # 友链页地址1，修改为你的友链页地址第三步：打开 Issues 友链抓取功能修改 hexo_circle_of_friends/fc_settings.yaml 文件：1234567GITHUB_FRIENDS_LINKS: &#123; enable: true, # true 开启github issue兼容 type: &quot;volantis&quot;, # volantis/stellar用户请在这里填写volantis owner: &quot;xaoxuu&quot;, # 填写你的github用户名 repo: &quot;friends&quot;, # 填写你的github仓库名 state: &quot;open&quot;, # 填写抓取的issue状态(open/closed)&#125;第四步：打开 Actions 运行权限见官方教程 #simplemode第五步：放置在博客中支持首页文章导航栏、文章任意位置，创建一个文件，以本站 friends/rss/index.md 为例：12345678910---seo_title: 朋友文章robots: noindex,nofollowmenu_id: postcomments: falsepost_list: true # 这就意味着页面会显示首页文章导航栏sidebar: [welcome, recent]---&#123;% timeline type:fcircle api:https://raw.githubusercontent.com/xaoxuu/friends-rss-generator/output/data.json %&#125;&#123;% endtimeline %&#125;其中，api 部分替换为自己仓库地址及其对应的 data.json 文件真实路径。其中，post_list: true 意味着页面会显示首页文章导航栏，搭配主题配置文件中的：12post-index: &#x27;朋友文章&#x27;: /friends/rss/即可实现在首页增加一个「朋友文章」栏目的效果。 你依然可以按照官方教程使用完整版。 本站示例仓库：@xaoxuu/friends-rss-generator 如果把 data.json 输出到 output 分支，可以直接使用下面的 API 来访问文件： 1https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator"},{"title":"开始您全新的博客之旅","date":"2024-03-25T16:10:58.783Z","updated":"2024-03-25T16:10:58.783Z","comments":true,"path":"wiki/stellar/index.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/","excerpt":"","text":"Stellar 是一个内置文档系统的简约商务风 Hexo 主题，支持丰富的标签和动态数据组件，帮助您简单从容地应对各种表达需求，十分推荐内容创作者使用 Stellar 开始您全新的博客之旅。 了解 Stellar 的设计理念“真正的简约远不止删繁就简，而是在纷繁中建立秩序。”人的注意力是有限的，要提高有效信息的醒目程度，就必须降低不重要信息醒目程度，删除所有无效信息。降低视觉密度增加留白，增加间距。减少颜色丰富度，大面积出现的是中性色，彩色必须有其特殊意义，意义相同的元素使用同一种颜色。提高有效信息优先级文章标题永远是最大的，对比度最高的不可交互的不重要的小标题（如侧边栏某个插件的标题）降低对比度与文章相关的不重要的小标题，使用小号字体删掉无效信息文章标签、字数、阅读量、评论数网站访问量、字数、搭建时间全局播放器（除了特殊文章） 开始前的准备工作 尽管我们致力于降低使用门槛，但是自建独立博客仍然需要一定的相关知识，markdown 常用语法是必须要掌握的，除此之外，您还需要知道 yaml 文件格式、简单的 git 知识，最最重要的是，遇到问题知道该如何高效地寻找答案： 翻阅和搜索文档 搜索 issues 中是否已经有解决办法 如果没有，新建 issue 并按照要求进行操作，详尽地描述您遇到的问题 如果您没有使用过 Hexo 也不要着急，我十分建议您去通读一遍 Hexo 中文文档。 https://hexo.io/zh-cn/docs/https://hexo.io/zh-cn/docs/ 此外，如果您从旧版本更新或者其它主题迁移，请确保环境版本不要太低，否则会产生兼容性问题： 建议的版本1234Hexo: 5.4.0 ~ 6.3.0hexo-cli: 4.3.0 ~ latestnode.js: 14.17.3 ～ 18.12.0 # 建议选择 LTS 版本，过高的版本 hexo 还没有进行兼容。npm: 6.14.13 ~ 8.19.2 安装与更新 稳定版最新版自定义引用源码安装方法在终端中输入：在 blog/_config.yml 文件中找到并修改：更新方法在 package.json 中修改 stellar 的版本号，然后执行：阅读 更新日志 进行迁移操作。适用范围稳定版适用于以内容创作为主，不需要自定义主题，追求稳定和可靠性的用户。安装方法把 Stellar 主题仓库添加为博客仓库的子模块在 blog/_config.yml 文件中找到并修改：更新方法打开终端并进入主题文件夹，执行：阅读 更新日志 进行迁移操作。适用范围最新版适用于以内容创作为主，不需要自定义主题，追求新特性的用户。安装方法把 Stellar 主题仓库 fork 到您的 GitHub 账号下把您 fork 的 Stellar 主题仓库添加为博客仓库的子模块在 blog/_config.yml 文件中找到并修改：更新方法在您 fork 的 Stellar 主题仓库打开终端，执行：阅读 更新日志 进行迁移操作。适用范围自定义版适用于对主题有自定义需求，且掌握了一定的前端知识和动手能力的用户。安装方法下载源码放到 themes/ 文件夹下面试用。适用范围仅适合测试，无法获得更新。 开源许可协议 项目中的许可声明文件应包含在所有副本中 本项目是由 @xaoxuu 设计和开发，后期也合并了 开源贡献者 提交的代码，使用 MIT License 开源许可协议进行授权，拷贝、分享或基于此进行创作时请遵守协议内容： 123456789101112131415161718192021MIT LicenseCopyright (c) 2021 xaoxuuPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE."},{"title":"实现「笔记」页面","date":"2024-03-25T16:10:58.790Z","updated":"2024-03-25T16:10:58.790Z","comments":true,"path":"wiki/stellar/notes.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/notes.html","excerpt":"","text":"创建一个项目，设置为不索引： blog/source/_data/projects.yml123456789101112Notes: name: 笔记 title: 笔记 description: 一个隐藏项目：笔记 index: false # sidebar: [toc] tags: 知识库 sections: &#x27;日常问题解决方案&#x27;: [100, 199] &#x27;移动端开发笔记&#x27;: [200, 299] &#x27;前端学习笔记&#x27;: [300, 399] &#x27;在线工具&#x27;: [400, 499] 然后笔记页面的 front-matter 中指定要高亮的 menu_id： blog/source/notes/index.md12345---layout: wikiwiki: Notesmenu_id: notes--- 这样就可以啦～"},{"title":"编写文章以及独立页面","date":"2024-03-25T16:10:58.786Z","updated":"2024-03-25T16:10:58.786Z","comments":true,"path":"wiki/stellar/pages.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/pages.html","excerpt":"","text":"文章封面 在文章列表页面或者其他位置显示的文章摘要卡片上面的图片称之为「文章封面」 自动生成封面 根据 tags 作为关键词为每一篇文章在线搜索封面： blog/_config.stellar.yml12article: auto_cover: true 引用外部图片 在文章的 front-matter 中写上 cover: xxx 即可。例如： blog/source/_posts/xxx.md12345---# 本地图片路径为 blog/source/assets/xaoxuu/blog/2020-0927a@1x.svg# 也可以直接引用图片直链 https://xxx.jpgcover: /assets/xaoxuu/blog/2020-0927a@1x.svg--- 显示效果 上面这种方式会显示title与description或者摘要，若你想要图片全显示，可以加入如下参数： blog/source/_posts/xxx.md12345678---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg # 必选poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选，默认为跟随主题的动态颜色 # white,red...--- Stellar v1.14.0 更换 cover-title cover-cat cover-subtitle cover-text-color 为 poster 为了显示美观，建议 topic 和 caption 选择其一与 headline 搭配使用。 显示效果填写 topic 与 headline 时大标题位于上方只填写 headline 或填写 headline 与 caption 时大标题位于下方 如果您想使用 Unsplash 搜索图片作为封面，可以在 cover 设置搜索关键词（用英文逗号隔开）： blog/source/_posts/xxx.md123---cover: workout,strava--- 内容摘要 自动生成摘要 建议您通过 description 或者 excerpt 方式生成摘要，但如果您希望自动从文章内容截取一定字数的文字作为摘要，可以这样设置： blog/_config.stellar.yml12article: auto_excerpt: 200 手动设置摘要 一篇文章开头一段文字描述就是摘要，摘要和正文用 &lt;!-- more --&gt; 隔开，前后一定要有空行。例如： blog/source/_posts/xxx.md123456789---cover: /assets/xaoxuu/blog/2020-0927a@1x.svg---在心率管家默默无闻地上线了一年多之后，现在终于打算来好好聊聊关于手机摄像头测量心率的那些事。本文参考了很多前辈的文章，将在文末列出。&lt;!-- more --&gt;后面是正文部分，在主页看不到。 AI摘要 感谢 @张洪Heo @Tianli 提供的项目 Post-Abstract-AI _config.stellar.yml12345# AI 摘要TianliGpt: post: true # 文章开启ai摘要 wiki: true # wiki项目开启ai摘要 api: 5Q5mpqRK5DkwT1X9Gi5e # 填写你的tianliGPT_key 如何获取 tianliGPT_key：到 爱发电 中购买，购买完成后，添加机器人客服：2102916311，回复 /chat 你的key 你的博客地址注意保留最后的斜杠 key与博客地址为绑定状态，所以本地调试时是无法接收到数据的。不绑定机器人可能会产生跨域问题，请将key绑定到机器人上。 文章模板 使用 Hexo 自带模板实现命令行创建新文章时自动生成相关信息。 根目录下 scaffolds 文件夹中编辑 post.md 的 font-matter： blog/scaffolds/post.md1234567891011121314---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags: []categories: []description: cover: banner: poster: # 海报（可选，全图封面卡片） topic: 标题上方的小字 # 可选 headline: 大标题 # 必选 caption: 标题下方的小字 # 可选 color: 标题颜色 # 可选--- 文章页 横幅图片 文章页面顶部区域可以显示长长的横幅图片，设置方法如下： blog/source/_posts/xxx.md1banner: /assets/xaoxuu/blog/2020-0927a@1x.svg 如果您想使用 Unsplash 搜索图片作为横幅，可以在 banner 中设置搜索关键词（用英文逗号隔开）： blog/source/_posts/xxx.md123---banner: workout,strava--- 指定一级标题 默认的一级标题是文章的 title，如果希望使用别的文字作为一级标题，可以指定 h1，例如： blog/source/_posts/xxx.md123---h1: 快速开始--- 文章索引与推荐 文章如果有分类和标签就会自动在主页出现「分类」、「标签」选项卡实现分类浏览，不需要手动添加页面。 文章分类 在文章列表页面会显示文章所属的第一级分类，例如： blog/source/_posts/xxx.md123---categories: [设计开发, iOS开发]--- 这样写就只会显示「设计开发」一级分类，而在文章页面顶部则会显示完整的面包屑导航。 文章标签 文章标签目前不可见，用于关键词、搜索、按标签检索、相关文章推荐等功能，例如： blog/source/_posts/xxx.md123---tags: [iOS, 心率]--- 相关文章推荐 要实现相关文章推荐功能，您需要安装插件： 然后在主题配置文件中开启： blog/_config.stellar.yml12345article: # npm i hexo-related-popular-posts related_posts: enable: true title: 您可能感兴趣的文章 开启后会在每篇文章的下方推荐相同类型的文章。 参考资料 填写引用文章的标题和链接： 12345678---references: - title: &#x27;心跳之旅—💗—iOS用手机摄像头检测心率(PPG)&#x27; url: https://punmy.cn/2016/07/28/15231176397746.html - title: &#x27;PPG光电容积脉搏波描记法技术概况&#x27; url: https://www.jianshu.com/p/695c131abfa5 ...--- 效果见这篇文章： https://xaoxuu.com/blog/20200927/#referenceshttps://xaoxuu.com/blog/20200927/#references 更多的独立页面 Stellar 同时具有博客和 Wiki 两个大模块，为了能够正确进行导航栏高亮，引入了 menu_id 来进行区分，通常情况下，layout: post 和 layout: wiki 两种布局模板可以自动为 sidebar.menu.post 和 sidebar.menu.wiki 的导航栏按钮高亮。自己创建的独立页面也可以在 front-matter 中指定 menu_id 来使某个按钮处于选中状态。 例如您有关于、友链两个页面，都希望高亮「更多」按钮： blog/source/about/index.md1234---menu_id: moretitle: 关于--- blog/source/friends/index.md1234---menu_id: moretitle: 友链--- 在主题配置文件中设置导航栏： blog/_config.stellar.yml1234sidebar: menu: ... more: &#x27;[更多](/more/)&#x27; 友链页面 友链被设计成标签，您可以在任何页面任何位置插入友链，详见： #友链标签https://xaoxuu.com/wiki/stellar/tag-plugins/#友链标签 关于页面 没有单独的关于页面布局，您可以自由组合丰富的标签来实现个性化的关于页面，例如：about、tabs、navbar、quot、timeline 标签。"},{"title":"更新日志与注意事项","date":"2024-03-25T16:10:58.790Z","updated":"2024-03-25T16:10:58.790Z","comments":true,"path":"wiki/stellar/releases.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/releases.html","excerpt":"","text":"版本命名规范：大版本 小版本 修复版本 大版本：较大范围改动和设计调整、重构 小版本：较小范围改动、增加删除功能，也可能包含部分修复 修复版本：仅包含修复或代码优化，可放心无缝升级 如何关注主题更新例如，您可以在自己博客任意位置用时间线标签显示主题最近一个版本更新内容：12&#123;% timeline api:https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/releases?per_page=1 %&#125;&#123;% endtimeline %&#125;"},{"title":"侧边栏配置","date":"2024-03-25T16:10:58.786Z","updated":"2024-03-25T16:10:58.786Z","comments":true,"path":"wiki/stellar/sidebar.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/sidebar.html","excerpt":"","text":"Logo 左上角的 logo 和标题取自站点根目录的配置文件： blog/_config.yml12title: 网站名称avatar: 头像 设置鼠标指上 subtitle 后翻转另一行字（您可以将鼠标移至左上角的Stellar查看效果） blog/_config.yml1subtitle: 标题1 | 标题2 如果您想用一个图片作为 logo，可以直接在主题配置文件 sidebar.logo.title 中设置： blog/_config.stellar.yml123sidebar: logo: title: &#x27;[&lt;img no-lazy height=&quot;32px&quot; src=&quot;xxx&quot;/&gt;](/)&#x27; Navbar（主导航栏） blog/_config.stellar.yml123456sidebar: menu: post: &#x27;[btn.blog](/)&#x27; wiki: &#x27;[btn.wiki](/wiki/)&#x27; notes: &#x27;[笔记](/notes/)&#x27; more: &#x27;[更多](/more/)&#x27; 侧边栏宽度有限，如何在不影响观感的情况下设置更多的主导航栏按钮呢？建议设置一个「更多」按钮，然后在「更多」页面的侧边栏放上列表组件。 Search（搜索） local_searchothers在 1.17.1 版本后开始支持，无需安装插件，默认开启。 blog/_config.stellar.yml12345678# 文章搜索search: service: local_search # local_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: true # 是否搜索代码块（需要content: true)请提交PR… 在 _config.stellar.yml 中设置搜索选项并配置你想在侧边栏中显示的位置。 然后在 widgets.yml 文件中配置侧边栏搜索组件 blog/source/_data/widgets.yml1234567891011121314search: layout: search filter: auto # auto or &#x27;/path&#x27; placeholder: 文章搜索 # 搜索框处显示的文字search_blog: layout: search filter: /blog/ # or /posts/ ... placeholder: 文章搜索search_docs: layout: search filter: /wiki/ placeholder: 文档搜索 您可以设置 filter 按地址过滤搜索结果，默认 auto 是智能选择，规则如下： layout: wiki：只在 /wiki/当前项目 中搜索 其它：站内搜索 你可以在某些页面中通过覆盖 search 组件的 filter 参数来定制化搜索范围，例如: 12345sidebar: - toc - layout: search override: search filter: /path/to/some 如果想始终进行不加过滤的站内搜索，那么设置为 filter: '' 即可。 Footer（页脚） blog/_config.stellar.yml1234567891011121314footer: social: github: icon: &#x27;&lt;img src=&quot;/assets/placeholder/social/08a41b181ce68.svg&quot;/&gt;&#x27; url: https:// music: icon: &#x27;&lt;img src=&quot;/assets/placeholder/social/3845874.svg&quot;/&gt;&#x27; url: https:// unsplash: icon: &#x27;&lt;img src=&quot;/assets/placeholder/social/3616429.svg&quot;/&gt;&#x27; url: https:// comments: icon: &#x27;&lt;img src=&quot;/assets/placeholder/social/942ebbf1a4b91.svg&quot;/&gt;&#x27; url: https:// 自定义组件 Stellar 支持丰富的自定义小组件，详见这篇文档： https://xaoxuu.com/wiki/stellar/widgets/https://xaoxuu.com/wiki/stellar/widgets/"},{"title":"网站和主题基本信息配置","date":"2024-03-25T16:10:58.790Z","updated":"2024-03-25T16:10:58.790Z","comments":true,"path":"wiki/stellar/theme-settings.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/theme-settings.html","excerpt":"","text":"站点信息 Stellar 会读取站点根目录下的 _config.yml 文件中的一些信息来生成您的网站，所以您需要修改以下值： blog/_config.yml12345678title: 您的网站名称avatar: 您的头像链接favicon: 您的网站iconsubtitle: 您的网站副标题# 多语言language: - zh-CN - en 更多关于 Hexo 文件的配置请移步官方文档 https://hexo.io/zh-cn/docs/configurationhttps://hexo.io/zh-cn/docs/configuration 多语言设置 主题中的默认文案都支持多语言，以简体中文为例，您可以在 themes/stellar/languages/zh-CN.yml 中修改文案。 更改网站优先语言，需要在站点根目录下的配置文件中进行修改： blog/_config.yml1234language: - zh-CN - en - zh-TW 创建主题配置文件 在博客根目录的 _config.yml 文件旁边新建一个文件： _config.stellar.yml ，在这个文件中的配置信息优先级高于主题文件夹中的配置文件。 头部标签自定义 Open Graph 默认生成 Open Graph 标签，如果您不希望生成它，可以在主题配置文件中关闭： blog/_config.stellar.yml123open_graph: enable: true twitter_id: # for open_graph meta"},{"title":"自定义小组件的配置与使用（8个）","date":"2024-03-25T16:10:58.803Z","updated":"2024-03-25T16:10:58.803Z","comments":true,"path":"wiki/stellar/widgets.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/widgets.html","excerpt":"","text":"实现并显示一个小组件需要两个步骤： 【配置】在组件库中声明组件 【使用】在需要的位置调用 组件库在 _data/widgets.yml 文件中，需要自己创建，内容形如： 123&#x27;我的小组件1&#x27;: layout: 小组件布局模板 ...(其它属性) 使用的地方有：【主题配置】、【项目配置】、【页面】，后者可以覆盖前者，例如： blog/source/_posts/xxx.md123---sidebar: [&#x27;我的小组件1&#x27;, &#x27;我的小组件2&#x27;]--- 组件库 在创建组件时，您可以使用以下这些 layout 布局： toc 这是文章/文档的目录树组件，显示文章和文档的目录结构： blog/source/_data/widgets.yml123456toc: layout: toc list_number: false # 是否显示序号 min_depth: 2 # 建议不要低于 2 即从 H2 标签开始解析（H1标签用于文章大标题） max_depth: 5 # 5 代表最多解析到 H5 标签 fallback: recent # Use a backup widget when toc does not exist. toc 的 fallback 默认是 recent，即一篇文章没有 TOC 的时候会显示一个 recent recent blog/source/_data/widgets.yml1234recent: layout: recent rss: # /atom.xml # npm i hexo-generator-feed limit: 5 # Count of posts 在 wiki 板块显示的是最近更新的 wiki 页面，其余地方显示最近更新的文章。 hexo 的覆盖规则是合并而不是替换，所以若不想使用 recent，除了在 _config.stellar.yml 中删除 recent 你还需要将此处的 recent 置空，即 blog/source/_data/widgets.yml1234recent:# layout: recent# rss: # /atom.xml # npm i hexo-generator-feed# limit: 5 # Count of posts 然后自己需要的地方用自己另建的一个 my_recent 组件 blog/source/_data/widgets.yml123my_recent: layout: recent ... related 相关文档组件，用于显示具有相同 tags 的其它项目列表，暂不支持自定义内容： Stellar 1.12.0 已将 wiki_more，更名为 related blog/source/_data/widgets.yml12related: layout: related markdown 这是一个自由度很高的标签，可以显示 markdown 文本内容： blog/source/_data/widgets.yml12345678910111213welcome: layout: markdown title: 欢迎欢迎 content: | 欢迎使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar/) 主题，下面是您的入门指南，祝您使用愉快！ &lt;br&gt; **第一步** 创建 `blog/_config.stellar.yml` 文件，在此文件中填写需要自定义的主题配置。 &lt;br&gt; **第二步** 创建 `blog/source/_data/widgets.yml` 文件，此文件中填写需要自定义的侧边栏组件，例如 `welcome` 组件。 &lt;br&gt; 如果有任何疑问，请先查阅 [文档](https://xaoxuu.com/wiki/stellar/)，如果文档中没有提供，请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues/) 向开发者询问。 tagcloud 标签云组件： blog/source/_data/widgets.yml12345678910111213tagcloud: layout: tagcloud title: 标签云 # 标签云配置 min_font: 12 max_font: 24 amount: 100 orderby: name order: 1 # 1, sac 升序；-1, desc 降序 color: false # 使用颜色 start_color: # 开始的颜色。您可使用十六进位值（&#x27;#b700ff&#x27;），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。 end_color: # 结束的颜色。您可使用十六进位值（&#x27;#b700ff&#x27;），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。 show_count: false # 显示每个标签的文章总数 ghuser 显示 GitHub 用户基础信息卡片： blog/source/_data/widgets.yml12345ghuser: layout: ghuser username: github # your github login username avatar: true # show avatar or not menu: true # show menu or not 因为它和侧边栏左上角默认的 header 功能存在重复，所以建议隐藏默认的 header 组件： blog/source/_posts/xxx.md12345---title: 某一篇文章sidebar: [ghuser, ...]header: false # 不显示左上角的 logo 和 menu--- ghrepo 显示 GitHub 仓库基础信息，需要搭配 repo 一起使用： blog/source/_data/widgets.yml12ghrepo: layout: ghrepo 需要在需要显示的文章页面的 front-matter 中按照如下格式写上仓库持有者和仓库名： blog/source/_posts/xxx.md123---repo: xaoxuu/hexo-theme-stellar--- 如果需要显示在 wiki 项目中，则在 _data/projects.yml 中填写到对应项目的信息中： blog/source/_data/projects.yml12345Stellar: title: Stellar subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27; repo: xaoxuu/hexo-theme-stellar ... timeline 动态说说朋友圈微博动态时间线组件，这个功能在 1.12.0 版本后开始支持： 动态数据是从 GitHub Issues 中拉取的，使用方法为： 在 widgets.yml 中新建配置 blog/source/_data/widgets.yml123456timeline: layout: timeline title: 近期动态 api: https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues # 若你想限制数量，在api链接后面加上?per_page=1指限制为1条 user: # 是否过滤只显示某个人发布的内容，如果要筛选多人，用英文逗号隔开 hide: # title,footer # 隐藏标题或底部 # 此功能需要 Stellar v1.13.0这个功能在 1.13.0 版本后开始支持。 https://xaoxuu.com/wiki/stellar/fcircle/https://xaoxuu.com/wiki/stellar/fcircle/ blog/source/_data/widgets.yml1234567# 愣着干啥，新建啊&#x27;朋友圈&#x27;: layout: timeline title: 近期动态 api: https://api.vlts.cc/output_data/v1/xaoxuu/friends-rss-generator # 你的朋友圈数据文件地址 type: fcircle limit: # 可通过这个限制最大数量这个功能在 1.18.0 版本后开始支持： blog/source/_data/widgets.yml123456weibo: layout: timeline title: 微博动态 api: https://raw.githubusercontent.com/GitHub用户名/仓库名/output/output/tweets.json # 你的微博爬取数据文件地址 type: weibo limit: 20 无论是哪种动态数据，你都可以在 _config.stellar.yml 中设置引用 blog/_config.stellar.yml1234sidebar: ... widgets: home: welcome, recent, 朋友圈, weibo 或者在你需要显示的页面引入，页面内引入优先于配置文件引入： blog/source/_posts/xxx.md123---sidebar: [ghuser, search, 朋友圈]--- 配置默认布局 主题配置中可以配置默认布局顺序，在这些页面中，侧边栏会按照指定的顺序从组件库中读取组件并显示： blog/_config.stellar.yml12345678910111213141516171819sidebar: ... widgets: #### 自动生成的页面 #### # 主页 home: search, welcome, recent, timeline # for home # 博客索引页 blog_index: search_blog, recent, timeline # for categories/tags/archives # 文档索引页 wiki_index: search_docs, recent, timeline # for wiki # 其它（404） others: search, welcome, recent, timeline # for 404 and ... #### 手动创建的页面 #### # 文章内页 post: toc, ghrepo, search, ghissues # for pages using &#x27;layout:post&#x27; # 文档内页 wiki: search, ghrepo, toc, ghissues, related # for pages using &#x27;layout:wiki&#x27; # 其它 layout:page 的页面 page: welcome, toc, search # for custom pages using &#x27;layout:page&#x27; 灵活用法 继承（覆盖）组件 适合有多个相似组件的情况，例如有多个时间线组件，显示规则相同，仅 api 地址不同： blog/source/_data/widgets.yml123456my_timeline_lite: layout: timeline title: 近期动态 user: xaoxuu hide: title,footer api: 在不同的页面设置不同的 api 地址： blog/source/_posts/xxx.md1234567---title: 某一篇文章sidebar: - toc # 只写一个字符串代表引用对应的通用组件 - override: my_timeline_lite api: https://xxx--- 匿名组件：仅在使用时创建 适合仅在一个页面或项目中才需要用到的组件，例如在某个页面的侧边栏放一个公告： blog/source/_posts/xxx.md12345678910111213---title: 某一篇文章sidebar: - toc # 只写一个字符串代表引用对应的通用组件 - layout: markdown title: &#x27;重要通知 [NOTE.2022-09]&#x27; content: | 请不要原封不动的把本站内容复制到贵站中使用，这样一方面不尊重原作者，另一方面也会因为存在大量重复内容影响贵站收录甚至降权。 从2022年9月起本站已不再开源，已经持有源码副本或`fork`的朋友请及时删除以防止被他人恶意搬运的情况继续发生。 [&gt; 了解详情](https://github.com/xaoxuu/xaoxuu.github.io#readme)--- 又或者在项目的配置文件中创建专属于这个项目的组件： blog/_data/projects.yml12345678910111213Stellar: name: Stellar title: Stellar - 每个人的独立博客 subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27; sidebar: - search - toc - ghrepo - layout: timeline title: 最近更新 api: https://api.github.xaox.cc/repos/xaoxuu/hexo-theme-stellar/releases?per_page=1 hide: footer ..."},{"title":"项目进度和近期计划","date":"2024-03-25T16:10:58.800Z","updated":"2024-03-25T16:10:58.800Z","comments":true,"path":"wiki/stellar/todo.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/todo.html","excerpt":"","text":""},{"title":"如何使用文档系统","date":"2024-03-25T16:10:58.796Z","updated":"2024-03-25T16:10:58.796Z","comments":true,"path":"wiki/stellar/wiki-settings.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/wiki-settings.html","excerpt":"","text":"Stellar 独创了其它 Hexo 主题所没有的 Wiki 系统，可以自动找到一个项目的所有文档分页，生成一个目录树，还可以手动指定顺序、标题、分组，而非依赖文件路径、文件名来排序和显示。 创建一个项目 在 blog/source/ 文件夹中创建一个 wiki 文件夹，在其中放入各个项目的文档。以 Stellar 项目为例： 1blog/source/wiki/stellar/index.md 设置布局模板和项目名称： blog/source/wiki/stellar/index.md12345---layout: wiki # 使用wiki布局模板wiki: Stellar # 这是项目名title: 这是分页标题--- 建议用这个文件作为项目的主页，并在文件夹内创建其它分页。Stellar 会把同一个项目的所有分页中 order 最小的一页作为项目的主页（其默认值为0）。 完善项目信息 在数据文件中创建项目文件，以 Stellar 为例： blog/source/_data/projects.yml1234567891011121314151617Stellar: name: Stellar title: Stellar - 每个人的独立博客 subtitle: &#x27;每个人的独立博客 | Designed by xaoxuu&#x27; tags: 博客主题 cover: true logo: src: /assets/wiki/stellar/icon.svg small: 112px large: 240px description: Stellar 是一个内置 wiki 系统的 hexo 主题，适合综合型站点使用。同时也拥有简约而精美的视觉设计和丰富的标签插件，帮助您简单从容地应对各种场合。 repo: xaoxuu/hexo-theme-stellar comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27; giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226 是否显示封面 项目可以显示一个全屏封面，封面占据一个屏幕的高度，会居中依次显示项目的 logo、标题、描述。开启项目封面方法如下： blog/source/_data/projects.yml123456Stellar: cover: true logo: src: /assets/wiki/stellar/icon.svg small: 120px large: 240px 如果 logo 中已经包含了项目标题，可以这样设置不显示项目标题： blog/source/_data/projects.yml12Stellar: cover: [logo, description] 项目文档标签 如果您有很多项目，有些项目是有相关性的，可以相同的 tags 值： blog/source/_data/projects.yml12Stellar: tags: 博客主题 也可以设置多个 tags 值： blog/source/_data/projects.yml12Stellar: tags: [博客主题, 开源项目] 项目的 GitHub 仓库信息 设置了 repo 值就会在侧边栏显示项目仓库的相关链接： blog/source/_data/projects.yml12Stellar: repo: xaoxuu/hexo-theme-stellar 项目评论设置 如果希望项目的所有分页使用相同的评论数据，可以在这里覆盖评论配置： blog/source/_data/projects.yml1234567Stellar: comment_title: &#x27;评论区仅供交流，有问题请提 [issue](https://github.com/xaoxuu/hexo-theme-stellar/issues) 反馈。&#x27; comments: giscus: data-repo: xaoxuu/hexo-theme-stellar data-mapping: number data-term: 226 是否需要被索引 如果您有些项目希望在项目列表中隐藏，可以设置 index 值： blog/source/_data/projects.yml12Stellar: index: false 文档排序 一个项目文档的多个分页之间以 order 的值作为排序依据，数字越小越靠前，最小的是项目主页。 侧边栏设置 侧边栏组件 如果您希望自定义某个项目的侧边栏组件，可以设置 sidebar 值： blog/source/_data/projects.yml12Notes: sidebar: [toc] 对目录树进行分组 如果您的项目文档分页较多，可以对目录树进行分组： blog/source/_data/projects.yml1234567Stellar: ... sections: &#x27;快速开始&#x27;: [0, 99] &#x27;基本使用&#x27;: [100, 199] &#x27;文档系统&#x27;: [200, 299] &#x27;进阶设定&#x27;: [900, 999] 左边是显示的标题，右边是 order 的区间，例如某页文档的 order 是 150，那么这页文档将会显示在「日常问题解决方案」这个组中。 指定 wiki 路径 在根目录中添加 wiki_dir 指定 Wiki 主页的路径，若不指定路径，您在点击返回所有项目时会回到主页而非回到所有项目。 blog/_config.yml1wiki_dir: wiki 例如书籍类的“项目”可以改为： blog/_config.yml1wiki_dir: books 例如商品/产品类的“项目”可以改为： blog/_config.yml1wiki_dir: products"},{"title":"容器类标签（9个）","date":"2024-03-25T16:11:03.203Z","updated":"2024-03-25T16:11:03.203Z","comments":true,"path":"wiki/stellar/tag-plugins/container.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/tag-plugins/container.html","excerpt":"","text":"ablock 普通块容器 note 标签就是使用 ablock 容器实现的，它们样式是相同的： 更名记录（Stellar 1.18.0）因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了，官方一直没有解释原因，后不得不改名：noteblock -&gt; grid -&gt; border -&gt; ablock详情见：#172 语法格式123&#123;% ablock [title] [color:color] [child:codeblock/tabs] %&#125;...&#123;% endablock %&#125; 写法如下12345&#123;% ablock Stellar v1.12.0 color:warning %&#125;因为原 noteblock 标签在升级到 hexo 6.0 之后跟官方库冲突了，官方一直没有解释原因，后不得不改名：noteblock -&gt; grid -&gt; border详情见：[#172](https://github.com/volantis-x/hexo-theme-volantis/issues/712)&#123;% endablock %&#125; 彩色代码块 设置 child:codeblock 并设置 color:颜色枚举 可以实现 10 种不同颜色的代码块，彩色代码块一般可以用在代码正确与错误的示范对比场景。 推荐的写法123func test() &#123; // ...&#125;不推荐的写法123func test() -&gt; () &#123; // ...&#125; 嵌套其它标签 例如嵌套一个 tabs 标签： 图文混排示例代码个人电脑作为办公设备时，我们该如何保护隐私？公司一般都会强制安装安防软件，这些软件要求开机自启动，要求有屏幕录制权限、完全的磁盘访问权限包括相册图库。因此如果使用自己的 MacBook 作为办公设备，必须要把生活区和工作区完全独立开，安装在两个磁盘分区，并且对磁盘分区进行加密。 folding 折叠容器 折叠块标签的语法格式为： 123&#123;% folding title [codeblock:bool] [open:bool] [color:color] %&#125;content&#123;% endfolding %&#125; 参数说明123codeblock: true/falseopen: true/falsecolor: red/orange/yellow/green/cyan/blue/purple/light/dark 彩色可折叠代码块 备注标签相较于旧版进行了增强，可以实现更多种颜色，还可以通过设置 child:codeblock 来实现可折叠的代码块。以下是一个默认打开的代码折叠框： 默认打开的代码折叠框123func test() &#123; print(&quot;hello world&quot;)&#125; 代码如下： 123&#123;% folding child:codeblock open:true color:yellow 默认打开的代码折叠框 %&#125;代码块&#123;% endfolding %&#125; 危险，请不要打开这个通过设置颜色，以实现更醒目的作用，但不要滥用色彩哦～警告，真的很危险通过设置颜色，以实现更醒目的作用，但不要滥用色彩哦～最后一次警告，千万不要打开这个不要说我们没有警告过你，Windows 10 不是為所有人設計，而是為每個人設計。 folders 多个折叠容器聚合 样式相比 folding 简单一些，适用于多个折叠标签平铺显示的场景，例如题目列表： 题目1这是答案1题目2这是答案2题目3这是答案3 代码如下： 12345678&#123;% folders %&#125;&lt;!-- folder 题目1 --&gt;这是答案1&lt;!-- folder 题目2 --&gt;这是答案2&lt;!-- folder 题目3 --&gt;这是答案3&#123;% endfolders %&#125; tabs 分栏容器 这个标签移植自 NexT 主题，但做了以下修改： 支持设置 align:center 来使内容居中 设置默认激活的标签方式为 active:1 而非 , 1（使用默认格式降低学习成本，且显式声明可读性更强） 不需要 &lt;!-- endtab --&gt; 来作为结束标识（因为 Stellar 会自动判断） 不需要 tabs id 来保证唯一性（因为 Stellar 会设置唯一标识） 不支持 @icon 方式设置图标（因为 Stellar 不再内置 fontawesome 图标库） 轮廓样式简化，可以搭配其它容器类标签嵌套使用。 演示效果示例代码图片代码块表格12let x = 123print(&quot;hello world&quot;) a b c a1 b1 c1 a2 b2 c2 gallery 图库容器 这个功能在 1.21.0 版本后开始支持，其内部只能填写 md 格式的图片。 @tianhao_wang@eberhard@eberhard@eberhard@eberhard@vklemen 写法如下12345678&#123;% gallery %&#125;![@tianhao_wang](https://images.unsplash.com/photo-1688142202243-e218ad203952?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDYzfEZ6bzN6dU9ITjZ3fHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1700994630045-f7a20df6d92e?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8MjN8fHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1533274221104-015a584a1005?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDE4fGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1539604214100-ab860d9082e0?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDIxfGJvOGpRS1RhRTBZfHxlbnwwfHx8fHw%3D)![@eberhard](https://images.unsplash.com/photo-1698843848092-588f9c1bb0bd?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwcm9maWxlLXBhZ2V8Mzh8fHxlbnwwfHx8fHw%3D)![@vklemen](https://images.unsplash.com/photo-1516571748831-5d81767b788d?q=80&amp;w=2574&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)&#123;% endgallery %&#125; banner 横幅容器 这个功能在 1.21.0 版本后开始支持，将会取代 about 组件，请尽快完成迁移。 用于独立页面顶部 随记收藏随记 写法如下123&#123;% banner 随记 bg:https://xaoxuu.com/assets/banner/notes.jpg %&#125;&#123;% navbar active:/notes/ [随记](/notes/) [收藏](/bookmark/) %&#125;&#123;% endbanner %&#125; 用于用户个人资料页 某某这是个人简介 写法如下12&#123;% banner 某某 这是个人简介 avatar:https://xaoxuu.com/assets/xaoxuu/avatar/rect-256@2x.png bg:https://xaoxuu.com/assets/banner/nebula.jpg %&#125;&#123;% endbanner %&#125; 用作文章摘要卡片 设置 link 可以让整个卡片响应点击事件，实现点击跳转到对应文章： 博客进阶：自动化部署本文讲了如何利用脚本和 GitHub Actions 简化博客搭建和部署流程，提高效率。 写法如下12&#123;% banner 博客进阶：自动化部署 本文讲了如何利用脚本和 GitHub Actions 简化博客搭建和部署流程，提高效率。 bg:https://xaoxuu.com/assets/xaoxuu/blog/2022-1126a@2x.jpg link:/blog/20221126/ %&#125;&#123;% endbanner %&#125; grid 网格分区容器 这个功能在 1.12.0 版本后开始支持，目前只支持显示一行两列，且手机端因宽度较窄会恢复为单列显示。 Unsplash PhotoThe Galactic Center is the rotational center of the Milky Way galaxy. Its central massive object is a supermassive black hole of about 4 million solar masses, which is called Sagittarius A*. Its mass is equal to four million suns. The center is located 25,800 light years away from Earth.Ōwhiro Bay, Wellington, New ZealandPublished on May 31, 2022SONY, ILCE-6000Free to use under the Unsplash License 普通块样式： 左侧内容右侧内容 卡片样式： 左侧内容右侧内容 示例代码： 123456&#123;% grid bg:block %&#125;&lt;!-- cell left --&gt;&lt;center&gt;左侧内容&lt;/center&gt;&lt;!-- cell right --&gt;&lt;center&gt;右侧内容&lt;/center&gt;&#123;% endgrid %&#125; bg 为可选参数，默认没有背景，可设置为 block/card 两种样式 about 关于块容器 方便在关于页面显示一段图文信息，比普通块容器稍微有一点点不一样： 1234567891011&#123;% about avatar:/assets/xaoxuu/avatar/rect-256@2x.png height:80px %&#125;&lt;img height=&quot;32px&quot; alt=&quot;XAOXUU&quot; src=&quot;/assets/xaoxuu/logo/180x30@2x.png&quot;&gt;**如果宇宙中真有什么终极的逻辑，那就是我们终有一天会在舰桥上重逢，直到生命终结。**XAOXUU 目前是一个 iOS 开发者，代表作品有：ProHUD、ValueX 等。在业余时间也开发了 Stellar 博客主题，更多的作品可以去项目主页查看，希望大家喜欢～&#123;% navbar [文章](/) [项目](/wiki/) [留言](#comments) [GitHub](https://github.com/xaoxuu/) %&#125;&#123;% endabout %&#125; 这个标签正在考虑重命名请发表您的建议 #198 swiper 轮播容器 默认一张图片是 50% 宽度，通过设置 width:min 设置为 25% 宽度，width:max 设置为 100% 宽度。 写法如下123456&#123;% swiper effect:cards %&#125;![](https://images.unsplash.com/photo-1625171515821-1870deb2743b?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=774&amp;q=80)![](https://images.unsplash.com/photo-1528283648649-33347faa5d9e?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=774&amp;q=80)![](https://images.unsplash.com/photo-1542272201-b1ca555f8505?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=774&amp;q=80)![](https://images.unsplash.com/photo-1524797905120-92940d3a18d6?ixlib=rb-4.0.3&amp;ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;auto=format&amp;fit=crop&amp;w=774&amp;q=80)&#123;% endswiper %&#125; 宽度切换效果写法如下123&#123;% swiper width:min/max %&#125;...&#123;% endswiper %&#125;123&#123;% swiper effect:cards/coverflow %&#125;...&#123;% endswiper %&#125; 注意一个页面只能设置一次，第一个 swiper 容器的效果全局生效。"},{"title":"数据集合类标签（5个）","date":"2024-03-25T16:11:03.206Z","updated":"2024-03-25T16:11:03.206Z","comments":true,"path":"wiki/stellar/tag-plugins/data.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/tag-plugins/data.html","excerpt":"","text":"timeline 时间线 支持静态和动态时间线数据源，用法非常多，详见这篇文章： https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ 静态时间线 静态数据是写死在 md 源文件中的，在 deploy 时就已经确定了。 2021 年 2 月 16 日主要部分功能已经开发的差不多了。2021 年 2 月 11 日今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。 写法如下1234567&#123;% timeline %&#125;&lt;!-- node 2021 年 2 月 16 日 --&gt;主要部分功能已经开发的差不多了。&#123;% image /assets/wiki/stellar/photos/hello@1x.png width:300px %&#125;&lt;!-- node 2021 年 2 月 11 日 --&gt;今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。&#123;% endtimeline %&#125; 动态时间线 动态说说朋友圈微博动态动态数据是从 GitHub Issues 中拉取的，使用方法为： 建一个仓库 创建一个 issue 并添加一个 label 进行测试 写 timeline 标签时加上 api:https://api.github.com/repos/your-name/your-repo/issues 例如： _posts/xxx.md1&#123;% timeline api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?direction=asc&amp;per_page=3 %&#125;&#123;% endtimeline %&#125; 效果如下： https://xaoxuu.com/wiki/stellar/fcircle/https://xaoxuu.com/wiki/stellar/fcircle/ _posts/xxx.md12&#123;% timeline type:fcircle api:https://raw.githubusercontent.com/xaoxuu/friends-rss-generator/output/data.json %&#125;&#123;% endtimeline %&#125; fork 爬虫 仓库 ，修改自己的仓库名 修改 .github/workflows/main.yml 中的微博ID为你想爬取的ID，修改完后每天会自动爬取你的微博，存储为 json 文件，输出文件在 output 分支 _posts/xxx.md1&#123;% timeline limit:20 type:weibo api:你的json文件地址 %&#125;&#123;% endtimeline %&#125; 静态 + 动态 用法同静态和动态单独使用时一样，例如： 1234&#123;% timeline reversed:true api:https://api.github.com/repos/xaoxuu/blog-timeline/issues?per_page=2 %&#125;&lt;!-- node 这条内容为静态数据 --&gt;这条内容为静态数据，静态数据在 `deploy` 时就已经确定了。&#123;% endtimeline %&#125; 数据筛选 只显示某个人的数据筛选最近3条todo筛选评论最多的3条建议 上述示例代码如下： 12345678&#123;% folders %&#125;&lt;!-- 只显示某个人的数据 --&gt;&#123;% timeline user:xaoxuu api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues %&#125;&#123;% endtimeline %&#125;&lt;!-- 筛选最近3条todo --&gt;&#123;% timeline api:https://api.github.com/repos/xaoxuu/hexo-theme-stellar/issues?labels=todo&amp;per_page=3 %&#125;&#123;% endtimeline %&#125;&lt;!-- 筛选评论最多的3条建议 --&gt;&#123;% timeline api:https://api.github.com/repos/volantis-x/hexo-theme-volantis/issues?labels=feature-request&amp;per_page=3&amp;sort=comments %&#125;&#123;% endtimeline %&#125;&#123;% endfolders %&#125; 更多用法详见： GitHub&nbsp;REST&nbsp;APIhttps://docs.github.com/en/rest/issues/issues#list-issues-assigned-to-the-authenticated-user friends 友链 您可以在任何位置插入友链组，支持静态数据和动态数据，静态数据需要写在数据文件中： blog/source/_data/links.yml123456&#x27;开源大佬&#x27;: - title: 某某某 url: https:// screenshot: avatar: description: 在需要的位置这样写： 1&#123;% friends 开源大佬 %&#125; 实现动态友链 从 xaoxuu/issues-json-generator 作为模板克隆或者 fork 仓库 修改 config.yml 并打开 github action 的运行权限 config.yml12345# 要抓取的 issues 配置issues: repo: xaoxuu/friends # 仓库持有者/仓库名（改成自己的） label: active # 筛选具有 active 标签的 issue ，取消此项则会提取所有 open 状态的 issue sort: # updated-desc # 排序，按最近更新，取消此项则按创建时间排序 不出意外的话，仓库中已经配置好了 issue 模板，只需要在模板中指定的位置填写信息就可以了。然后在自己的仓库里提交一个 issue 并将 Label 设置为 active 进行测试。 提交完 issue 一分钟左右，如果仓库中出现了 output 分支提交，可以点击查看一下文件内容是否已经包含了刚刚提交的 issue 中的数据，如果包含，那么前端页面就可以使用友链数据了： 1&#123;% friends api:https://raw.githubusercontent.com/xaoxuu/friends/output/v2/data.json %&#125; 数据托管与加速 特别感谢特别感谢小冰博客的加速访问方案，解决了直接请求 GitHub API 速度过慢的问题，详见 小冰博客 的教程。 支持把数据托管到任何其他地方来使用，例如： 1&#123;% friends api:https://api.vlts.cc/output_data/v2/xaoxuu/friends %&#125; Stellar 1.13.0动态数据 API 升级至 v2 版本，原使用 issue-api 仓库的需要将友链仓库同步更新。v1 版本已经停止维护。 你可以有 N 种办法加速访问 GitHub 仓库里的文件。 sites 网站卡片 您可以在任何位置插入网站卡片组，支持静态数据和动态数据，静态数据需要写在数据文件中： blog/source/_data/links.yml123456&#x27;分组名&#x27;: - title: 某某某 url: https:// screenshot: avatar: description: 在需要的位置这样写： 1&#123;% sites 分组名 %&#125; Stellar v1.13.0原 friends 和 sites 标签数据合并至 links.yml 文件，动态数据使用方法同友链，数据源格式相同，与友链共享数据，仅样式不同，也可以用 sites 标签做友链。 ghcard 卡片 写法如下12&#123;% ghcard xaoxuu %&#125;&#123;% ghcard xaoxuu/hexo-theme-stellar theme:dark %&#125; GitHub&nbsp;Card&nbsp;APIhttps://github.com/anuraghazra/github-readme-stats toc 文档目录树 1&#123;% toc wiki:xxx [open:true] [display:mobile] title %&#125;"},{"title":"图表类标签（3个）","date":"2024-03-25T16:11:03.209Z","updated":"2024-03-25T16:11:03.209Z","comments":true,"path":"wiki/stellar/tag-plugins/diagram.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/tag-plugins/diagram.html","excerpt":"","text":"echarts图表 echarts图表源码mermaid-activemermaid echarts_contents['echarts_0'] = { title: { text: 'Stacked Line' }, tooltip: { trigger: 'axis' }, legend: { data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { name: 'Email', type: 'line', stack: 'Total', data: [120, 132, 101, 134, 90, 230, 210] }, { name: 'Union Ads', type: 'line', stack: 'Total', data: [220, 182, 191, 234, 290, 330, 310] }, { name: 'Video Ads', type: 'line', stack: 'Total', data: [150, 232, 201, 154, 190, 330, 410] }, { name: 'Direct', type: 'line', stack: 'Total', data: [320, 332, 301, 334, 390, 330, 320] }, { name: 'Search Engine', type: 'line', stack: 'Total', data: [820, 932, 901, 934, 1290, 1330, 1320] } ] }; 说明这是一个测试mermaidflowchart TB&#13; c1-->a2&#13; subgraph one&#13; a1-->a2&#13; end&#13; subgraph two&#13; b1-->b2&#13; end&#13; subgraph three&#13; c1-->c2&#13; endecharts echarts_contents['echarts_0'] = { title: { text: 'Stacked Line' }, tooltip: { trigger: 'axis' }, legend: { data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { name: 'Email', type: 'line', stack: 'Total', data: [120, 132, 101, 134, 90, 230, 210] }, { name: 'Union Ads', type: 'line', stack: 'Total', data: [220, 182, 191, 234, 290, 330, 310] }, { name: 'Video Ads', type: 'line', stack: 'Total', data: [150, 232, 201, 154, 190, 330, 410] }, { name: 'Direct', type: 'line', stack: 'Total', data: [320, 332, 301, 334, 390, 330, 320] }, { name: 'Search Engine', type: 'line', stack: 'Total', data: [820, 932, 901, 934, 1290, 1330, 1320] } ]}; 这是一个echarts测试 echarts_contents['echarts_0'] = { title: { text: 'Stacked Line' }, tooltip: { trigger: 'axis' }, legend: { data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { name: 'Email', type: 'line', stack: 'Total', data: [120, 132, 101, 134, 90, 230, 210] }, { name: 'Union Ads', type: 'line', stack: 'Total', data: [220, 182, 191, 234, 290, 330, 310] }, { name: 'Video Ads', type: 'line', stack: 'Total', data: [150, 232, 201, 154, 190, 330, 410] }, { name: 'Direct', type: 'line', stack: 'Total', data: [320, 332, 301, 334, 390, 330, 320] }, { name: 'Search Engine', type: 'line', stack: 'Total', data: [820, 932, 901, 934, 1290, 1330, 1320] } ]}; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&#123; title: &#123; text: &#x27;Stacked Line&#x27; &#125;, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, legend: &#123; data: [&#x27;Email&#x27;, &#x27;Union Ads&#x27;, &#x27;Video Ads&#x27;, &#x27;Direct&#x27;, &#x27;Search Engine&#x27;] &#125;, grid: &#123; left: &#x27;3%&#x27;, right: &#x27;4%&#x27;, bottom: &#x27;3%&#x27;, containLabel: true &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, xAxis: &#123; type: &#x27;category&#x27;, boundaryGap: false, data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;] &#125;, yAxis: &#123; type: &#x27;value&#x27; &#125;, series: [ &#123; name: &#x27;Email&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [120, 132, 101, 134, 90, 230, 210] &#125;, &#123; name: &#x27;Union Ads&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [220, 182, 191, 234, 290, 330, 310] &#125;, &#123; name: &#x27;Video Ads&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [150, 232, 201, 154, 190, 330, 410] &#125;, &#123; name: &#x27;Direct&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [320, 332, 301, 334, 390, 330, 320] &#125;, &#123; name: &#x27;Search Engine&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [820, 932, 901, 934, 1290, 1330, 1320] &#125; ]&#125;graph LR&#13; A(Section A) -->|option 1| B(Section A)&#13; B -->|option 2| C(Section C) gitGraph&#13; commit&#13; commit&#13; branch develop&#13; commit&#13; commit&#13; commit&#13; checkout main&#13; commit&#13; commit 说明这是一个测试mermaidflowchart TB&#13; c1-->a2&#13; subgraph one&#13; a1-->a2&#13; end&#13; subgraph two&#13; b1-->b2&#13; end&#13; subgraph three&#13; c1-->c2&#13; endecharts echarts_contents['echarts_0'] = { title: { text: 'Stacked Line' }, tooltip: { trigger: 'axis' }, legend: { data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { name: 'Email', type: 'line', stack: 'Total', data: [120, 132, 101, 134, 90, 230, 210] }, { name: 'Union Ads', type: 'line', stack: 'Total', data: [220, 182, 191, 234, 290, 330, 310] }, { name: 'Video Ads', type: 'line', stack: 'Total', data: [150, 232, 201, 154, 190, 330, 410] }, { name: 'Direct', type: 'line', stack: 'Total', data: [320, 332, 301, 334, 390, 330, 320] }, { name: 'Search Engine', type: 'line', stack: 'Total', data: [820, 932, 901, 934, 1290, 1330, 1320] } ]}; 这是一个echarts测试 echarts_contents['echarts_0'] = { title: { text: 'Stacked Line' }, tooltip: { trigger: 'axis' }, legend: { data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { name: 'Email', type: 'line', stack: 'Total', data: [120, 132, 101, 134, 90, 230, 210] }, { name: 'Union Ads', type: 'line', stack: 'Total', data: [220, 182, 191, 234, 290, 330, 310] }, { name: 'Video Ads', type: 'line', stack: 'Total', data: [150, 232, 201, 154, 190, 330, 410] }, { name: 'Direct', type: 'line', stack: 'Total', data: [320, 332, 301, 334, 390, 330, 320] }, { name: 'Search Engine', type: 'line', stack: 'Total', data: [820, 932, 901, 934, 1290, 1330, 1320] } ]}; ---&#13;title: Animal example&#13;---&#13;classDiagram&#13; note \"From Duck till Zebra\"&#13; Animal &#60;|-- Duck&#13; note for Duck \"can fly\\ncan swim\\ncan dive\\ncan help in debugging\"&#13; Animal &#60;|-- Fish&#13; Animal &#60;|-- Zebra&#13; Animal : +int age&#13; Animal : +String gender&#13; Animal: +isMammal()&#13; Animal: +mate()&#13; class Duck{&#13; +String beakColor&#13; +swim()&#13; +quack()&#13; }&#13; class Fish{&#13; -int sizeInFeet&#13; -canEat()&#13; }&#13; class Zebra{&#13; +bool is_wild&#13; +run()&#13; } graph LR&#13; A(Section A) -->|option 1| B(Section A)&#13; B -->|option 2| C(Section C) gitGraph&#13; commit&#13; commit&#13; branch develop&#13; commit&#13; commit&#13; commit&#13; checkout main&#13; commit&#13; commit sequenceDiagram&#13; autonumber&#13; Alice->>John: Hello John, how are you?&#13; loop Healthcheck&#13; John->>John: Fight against hypochondria&#13; end&#13; Note right of John: Rational thoughts!&#13; John-->>Alice: Great!&#13; John->>Bob: How about you?&#13; Bob-->>John: Jolly good! stateDiagram&#13; direction LR&#13; [*] --> A&#13; A --> B&#13; B --> C&#13; state B {&#13; direction LR&#13; a --> b&#13; }&#13; B --> D erDiagram&#13; CUSTOMER ||--o{ ORDER : places&#13; CUSTOMER {&#13; string name&#13; string custNumber&#13; string sector&#13; }&#13; ORDER ||--|{ LINE-ITEM : contains&#13; ORDER {&#13; int orderNumber&#13; string deliveryAddress&#13; }&#13; LINE-ITEM {&#13; string productCode&#13; int quantity&#13; float pricePerUnit&#13; } journey&#13; title My working day&#13; section Go to work&#13; Make tea: 5: Me&#13; Go upstairs: 3: Me&#13; Do work: 1: Me, Cat&#13; section Go home&#13; Go downstairs: 5: Me&#13; Sit down: 5: Me pie title Pets adopted by volunteers&#13; \"Dogs\" : 386&#13; \"Cats\" : 85&#13; \"Rats\" : 15 quadrantChart&#13; title Reach and engagement of campaigns&#13; x-axis Low Reach --> High Reach&#13; y-axis Low Engagement --> High Engagement&#13; quadrant-1 We should expand&#13; quadrant-2 Need to promote&#13; quadrant-3 Re-evaluate&#13; quadrant-4 May be improved&#13; Campaign A: [0.3, 0.6]&#13; Campaign B: [0.45, 0.23]&#13; Campaign C: [0.57, 0.69]&#13; Campaign D: [0.78, 0.34]&#13; Campaign E: [0.40, 0.34]&#13; Campaign F: [0.35, 0.78] mindmap&#13; root((mindmap))&#13; Origins&#13; Long history&#13; ::icon(fa fa-book)&#13; Popularisation&#13; British popular psychology author Tony Buzan&#13; Research&#13; On effectiveness&#60;br/>and features&#13; On Automatic creation&#13; Uses&#13; Creative techniques&#13; Strategic planning&#13; Argument mapping&#13; Tools&#13; Pen and paper&#13; Mermaid timeline&#13; title MermaidChart 2023 Timeline&#13; section 2023 Q1 &#60;br> Release Personal Tier&#13; Buttet 1 : sub-point 1a : sub-point 1b&#13; : sub-point 1c&#13; Bullet 2 : sub-point 2a : sub-point 2b&#13; section 2023 Q2 &#60;br> Release XYZ Tier&#13; Buttet 3 : sub-point &#60;br> 3a : sub-point 3b&#13; : sub-point 3c&#13; Bullet 4 : sub-point 4a : sub-point 4b sankey-beta&#13;&#13;%% source,target,value&#13;Electricity grid,Over generation / exports,104.453&#13;Electricity grid,Heating and cooling - homes,113.726&#13;Electricity grid,H2 conversion,27.14 C4Context&#13; title System Context diagram for Internet Banking System&#13; Enterprise_Boundary(b0, \"BankBoundary0\") {&#13; Person(customerA, \"Banking Customer A\", \"A customer of the bank, with personal bank accounts.\")&#13; Person(customerB, \"Banking Customer B\")&#13; Person_Ext(customerC, \"Banking Customer C\", \"desc\")&#13;&#13; Person(customerD, \"Banking Customer D\", \"A customer of the bank, &#60;br/> with personal bank accounts.\")&#13;&#13; System(SystemAA, \"Internet Banking System\", \"Allows customers to view information about their bank accounts, and make payments.\")&#13;&#13; Enterprise_Boundary(b1, \"BankBoundary\") {&#13;&#13; SystemDb_Ext(SystemE, \"Mainframe Banking System\", \"Stores all of the core banking information about customers, accounts, transactions, etc.\")&#13;&#13; System_Boundary(b2, \"BankBoundary2\") {&#13; System(SystemA, \"Banking System A\")&#13; System(SystemB, \"Banking System B\", \"A system of the bank, with personal bank accounts. next line.\")&#13; }&#13;&#13; System_Ext(SystemC, \"E-mail system\", \"The internal Microsoft Exchange e-mail system.\")&#13; SystemDb(SystemD, \"Banking System D Database\", \"A system of the bank, with personal bank accounts.\")&#13;&#13; Boundary(b3, \"BankBoundary3\", \"boundary\") {&#13; SystemQueue(SystemF, \"Banking System F Queue\", \"A system of the bank.\")&#13; SystemQueue_Ext(SystemG, \"Banking System G Queue\", \"A system of the bank, with personal bank accounts.\")&#13; }&#13; }&#13; }&#13;&#13; BiRel(customerA, SystemAA, \"Uses\")&#13; BiRel(SystemAA, SystemE, \"Uses\")&#13; Rel(SystemAA, SystemC, \"Sends e-mails\", \"SMTP\")&#13; Rel(SystemC, customerA, \"Sends e-mails to\")&#13;&#13; UpdateElementStyle(customerA, $fontColor=\"red\", $bgColor=\"grey\", $borderColor=\"red\")&#13; UpdateRelStyle(customerA, SystemAA, $textColor=\"blue\", $lineColor=\"blue\", $offsetX=\"5\")&#13; UpdateRelStyle(SystemAA, SystemE, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-10\")&#13; UpdateRelStyle(SystemAA, SystemC, $textColor=\"blue\", $lineColor=\"blue\", $offsetY=\"-40\", $offsetX=\"-50\")&#13; UpdateRelStyle(SystemC, customerA, $textColor=\"red\", $lineColor=\"red\", $offsetX=\"-50\", $offsetY=\"20\")&#13;&#13; UpdateLayoutConfig($c4ShapeInRow=\"3\", $c4BoundaryInRow=\"1\") requirementDiagram&#13;&#13; requirement test_req {&#13; id: 1&#13; text: the test text.&#13; risk: high&#13; verifymethod: test&#13; }&#13;&#13; element test_entity {&#13; type: simulation&#13; }&#13;&#13; test_entity - satisfies -> test_req stateDiagram&#13; [*] --> Still&#13; Still --> [*]&#13;&#13; Still --> Moving&#13; Moving --> Still&#13; Moving --> Crash&#13; Crash --> [*] flowchart TB&#13; c1-->a2&#13; subgraph one&#13; a1-->a2&#13; end&#13; subgraph two&#13; b1-->b2&#13; end&#13; subgraph three&#13; c1-->c2&#13; end flowchart TB&#13; c1-->a2&#13; subgraph one&#13; a1-->a2&#13; end&#13; subgraph two&#13; b1-->b2&#13; end&#13; subgraph three&#13; c1-->c2&#13; end 说明这是一个测试mermaidflowchart TB&#13; c1-->a2&#13; subgraph one&#13; a1-->a2&#13; end&#13; subgraph two&#13; b1-->b2&#13; end&#13; subgraph three&#13; c1-->c2&#13; end演示效果代码示例graph LR&#13; A(Section A) -->|option 1| B(Section A)&#13; B -->|option 2| C(Section C)gitGraph&#13; commit&#13; commit&#13; branch develop&#13; commit&#13; commit&#13; commit&#13; checkout main&#13; commit&#13; commitecharts echarts_contents['echarts_0'] = { title: { text: 'Stacked Line' }, tooltip: { trigger: 'axis' }, legend: { data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { name: 'Email', type: 'line', stack: 'Total', data: [120, 132, 101, 134, 90, 230, 210] }, { name: 'Union Ads', type: 'line', stack: 'Total', data: [220, 182, 191, 234, 290, 330, 310] }, { name: 'Video Ads', type: 'line', stack: 'Total', data: [150, 232, 201, 154, 190, 330, 410] }, { name: 'Direct', type: 'line', stack: 'Total', data: [320, 332, 301, 334, 390, 330, 320] }, { name: 'Search Engine', type: 'line', stack: 'Total', data: [820, 932, 901, 934, 1290, 1330, 1320] } ]}; 这是一个mermaid测试flowchart TB&#13; c1-->a2&#13; subgraph one&#13; a1-->a2&#13; end&#13; subgraph two&#13; b1-->b2&#13; end&#13; subgraph three&#13; c1-->c2&#13; end演示效果代码示例graph LR&#13; A(Section A) -->|option 1| B(Section A)&#13; B -->|option 2| C(Section C)gitGraph&#13; commit&#13; commit&#13; branch develop&#13; commit&#13; commit&#13; commit&#13; checkout main&#13; commit&#13; commit 这是一个echarts测试 echarts_contents['echarts_0'] = { title: { text: 'Stacked Line' }, tooltip: { trigger: 'axis' }, legend: { data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine'] }, grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, toolbox: { feature: { saveAsImage: {} } }, xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, yAxis: { type: 'value' }, series: [ { name: 'Email', type: 'line', stack: 'Total', data: [120, 132, 101, 134, 90, 230, 210] }, { name: 'Union Ads', type: 'line', stack: 'Total', data: [220, 182, 191, 234, 290, 330, 310] }, { name: 'Video Ads', type: 'line', stack: 'Total', data: [150, 232, 201, 154, 190, 330, 410] }, { name: 'Direct', type: 'line', stack: 'Total', data: [320, 332, 301, 334, 390, 330, 320] }, { name: 'Search Engine', type: 'line', stack: 'Total', data: [820, 932, 901, 934, 1290, 1330, 1320] } ]}; tree 树形结构root1 写法如下1234567{% timeline %&#125;&lt;!-- node 2021 年 2 月 16 日 --&gt;主要部分功能已经开发的差不多了。{% image /assets/wiki/stellar/photos/hello@1x.png width:300px %&#125;&lt;!-- node 2021 年 2 月 11 日 --&gt;今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。{% endtimeline %&#125;单影只人心是一座孤岛，即便岛上繁花似锦，四季更替，依然只是一个人的风景。繁华也好，萧条也好，都只属于一个人。记得有人说过这样一句话：一人花开，一人花落，这些年从头到尾，无人问询。那种寥落，如轩窗外的一片月色，独自在树梢起舞，却无人欣赏它清丽的舞姿。又像是一阙小词，笔笔皆清冷，笔笔皆寂寥。且听风吟2023.09.08留言123游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。2023.09.08诗词节选游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选12345root2单影只人心是一座孤岛，即便岛上繁花似锦，四季更替，依然只是一个人的风景。繁华也好，萧条也好，都只属于一个人。记得有人说过这样一句话：一人花开，一人花落，这些年从头到尾，无人问询。那种寥落，如轩窗外的一片月色，独自在树梢起舞，却无人欣赏它清丽的舞姿。又像是一阙小词，笔笔皆清冷，笔笔皆寂寥。且听风吟2023.09.08留言123游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。2023.09.08诗词节选游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选12345root3单影只人心是一座孤岛，即便岛上繁花似锦，四季更替，依然只是一个人的风景。繁华也好，萧条也好，都只属于一个人。记得有人说过这样一句话：一人花开，一人花落，这些年从头到尾，无人问询。那种寥落，如轩窗外的一片月色，独自在树梢起舞，却无人欣赏它清丽的舞姿。又像是一阙小词，笔笔皆清冷，笔笔皆寂寥。且听风吟2023.09.08留言123游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。2023.09.08诗词节选游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选12345root4单影只人心是一座孤岛，即便岛上繁花似锦，四季更替，依然只是一个人的风景。繁华也好，萧条也好，都只属于一个人。记得有人说过这样一句话：一人花开，一人花落，这些年从头到尾，无人问询。那种寥落，如轩窗外的一片月色，独自在树梢起舞，却无人欣赏它清丽的舞姿。又像是一阙小词，笔笔皆清冷，笔笔皆寂寥。且听风吟2023.09.08留言123游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。2023.09.08诗词节选游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选12345 树形结构root1 写法如下12345678{% timeline %&#125;&lt;!-- node 2021 年 2 月 16 日 --&gt;主要部分功能已经开发的差不多了。{% image /assets/wiki/stellar/photos/hello@1x.png width:300px %&#125;&lt;!-- node 2021 年 2 月 11 日 --&gt;今天除夕，也是生日，一个人在外地过年+过生日，熬夜开发新主题，尽量在假期结束前放出公测版。{% endtimeline %&#125;![@tianhao_wang](https://images.unsplash.com/photo-1688142202243-e218ad203952?w=800&amp;auto=format&amp;fit=crop&amp;q=60&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHx0b3BpYy1mZWVkfDYzfEZ6bzN6dU9ITjZ3fHxlbnwwfHx8fHw%3D)123123dfdgf 写法如下download1234567891011121314151617&#123; root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;&#123; root2:[node1,node2]&#125;&#123; root3:[node1,node2]&#125;&#123; root4:[node1,node2]&#125;123123 写法如下download123456789101112131415{ root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;## sf{ root2:[node1,node2]&#125;{ root3:[node1,node2]&#125;{ root4:[node1,node2]&#125;写法如下download12345{ root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;root2123123dfdgf 写法如下download1234567891011121314151617&#123; root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;&#123; root2:[node1,node2]&#125;&#123; root3:[node1,node2]&#125;&#123; root4:[node1,node2]&#125;123123 写法如下download123456789101112131415{ root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;## sf{ root2:[node1,node2]&#125;{ root3:[node1,node2]&#125;{ root4:[node1,node2]&#125;写法如下download12345{ root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;123123123dfdgf 写法如下download1234567891011121314151617&#123; root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;&#123; root2:[node1,node2]&#125;&#123; root3:[node1,node2]&#125;&#123; root4:[node1,node2]&#125;123123 写法如下download123456789101112131415{ root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;## sf{ root2:[node1,node2]&#125;{ root3:[node1,node2]&#125;{ root4:[node1,node2]&#125;写法如下download12345{ root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;root4123123dfdgf 写法如下download1234567891011121314151617&#123; root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;&#123; root2:[node1,node2]&#125;&#123; root3:[node1,node2]&#125;&#123; root4:[node1,node2]&#125;123123 写法如下download123456789101112131415{ root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;## sf{ root2:[node1,node2]&#125;{ root3:[node1,node2]&#125;{ root4:[node1,node2]&#125;写法如下download12345{ root1:[node1,node2] node2:[node3,node4,node5] node5:[node6]&#125;"},{"title":"表达类标签（15+个）","date":"2024-03-25T16:11:03.203Z","updated":"2024-03-25T16:11:03.203Z","comments":true,"path":"wiki/stellar/tag-plugins/express.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/tag-plugins/express.html","excerpt":"","text":"emoji 表情 效果演示语法格式引入表情包内置了可配置的表情标签 使用方法如下： 1234&#123;% emoji 爱你 %&#125;&#123;% emoji blobcat ablobcatrainbow %&#125;&#123;% emoji blobcat ablobcatattentionreverse %&#125;&#123;% emoji tieba 滑稽 %&#125;1&#123;% emoji [source] name [height:1.75em] %&#125; 其中 source 可省略，默认为配置中的第一个 source（详见「引入表情包」部分） 如果对高度有特别要求，可以指定高度，例如：1&#123;% emoji blobcat ablobcatrainbow height:4em %&#125; 表情速查表1：stellar表情标签索引 表情速查表2：Stellar内嵌blobcat小表情 blog/_config.stellar.yml12345678tag_plugins: ... emoji: default: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/$&#123;name&#125;.gif twemoji: https://gcore.jsdelivr.net/gh/twitter/twemoji/assets/svg/$&#123;name&#125;.svg qq: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/$&#123;name&#125;.gif aru: https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/$&#123;name&#125;.gif tieba: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/$&#123;name&#125;.png 在配置文件中，文件名用 ${name} 代替。 mark 行内文本标记 支持多彩标记，包括：默认 红 橙 黄 绿 青 蓝 紫 浅 深 警告 错误 一共 12 种颜色。 1支持多彩标记，包括：&#123;% mark 默认 %&#125; &#123;% mark 红 color:red %&#125; &#123;% mark 橙 color:orange %&#125; &#123;% mark 黄 color:yellow %&#125; &#123;% mark 绿 color:green %&#125; &#123;% mark 青 color:cyan %&#125; &#123;% mark 蓝 color:blue %&#125; &#123;% mark 紫 color:purple %&#125; &#123;% mark 浅 color:light %&#125; &#123;% mark 深 color:dark %&#125; &#123;% mark 警告 color:warning %&#125; &#123;% mark 错误 color:error %&#125; 一共 12 种颜色。 tag 标签 这个效果类似于 mark 标签，但是更适合一批标签独占一行来使用，支持链接： Stellar Hexo GitHub Gitea 如果没有指定颜色，且没有设置默认颜色，则随机取一个颜色，快来试试吧～ 1234&#123;% tag Stellar https://xaoxuu.com/wiki/stellar/ %&#125;&#123;% tag Hexo https://hexo.io/ %&#125;&#123;% tag GitHub https://github.com/xaoxuu/ %&#125;&#123;% tag Gitea https://git.xaox.cc/ color:green %&#125; image 图片标签 图片标签是一个精心设计的应对各种尺寸插图的标签，对于大图，可以放置一个「下载」按钮，语法格式如下： 1&#123;% image src [description] [download:bool/string] [width:px] [padding:px] [bg:hex] %&#125; 参数说明123456src: 图片地址description: 图片描述download: href # 下载地址，设置此值后鼠标放在图片上会显示下载地址，如果下载地址为图片地址，可以设置为 truewidth: 200px # 图片宽度padding: 16px # 图片四周填充宽度bg: &#x27;#ffffff&#x27; # 图片区域背景颜色，16进制 大尺寸图片 无论在什么宽度的设备上都希望横向铺满的图片，一般不需要额外操作。可以在链接后面写上图片描述，如有必要，可以通过设置 download:true 使其显示一个「下载」按钮链接指向图片地址，如果下载链接与显示的图片地址不同，可以 download:下载链接 来使其能够下载原图。 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 来自澳大利亚的 Pieter de Vries 使用 iPhone 12 Pro Max 拍摄。 写法如下12&#123;% image /assets/wiki/stellar/photos/183e71e0ad995.jpg 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone-rohit_vohra_12172020.zip %&#125;&#123;% image /assets/wiki/stellar/photos/bc7bda18328da.jpg 来自澳大利亚的 Pieter de Vries 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone_pieter_de_vries_011221.zip %&#125; 小尺寸图片优化 宽度较小而高度较大的图片，可以设置宽、高、填充间距、背景色等对其布局进行优化，使得它在不同宽度的屏幕下都能获得不错的视觉体验： 有底色的图片没有底色的图片有底色的图片，可以填充图片底色： 1&#123;% image /assets/xaoxuu/mirror/apple/documentation/watchkit/06d45110-1dd7-49a4-a413-9f5159ecdd0e.png width:200px padding:16px bg:white %&#125; 提示鼠标拖拽一下图片可以看看原图 如果不进行约束，在宽屏设备上阅读体验很糟糕没有底色的图片，可以填充 bg:var(--card) 动态颜色，能够适配暗黑模式： 1&#123;% image /assets/wiki/stellar/icon.svg bg:var(--card) padding:16px %&#125; 支持 Fancybox 插件点击放大 由于 Stellar 主题的插件具有按需加载的特性，所以 Fancybox 插件默认也是已经配置好了的，在任意 image 标签中增加 fancybox:true 参数即可为特定图片开启缩放功能。如果一个页面没有任何地方使用，则不会加载 Fancybox 插件。 图片来自 Apple 官网 如果您希望全站所有的 image 标签都开启此功能，可在主题配置文件中修改以下参数： blog/_config.stellar.yml12345######## Tag Plugins ########tag_plugins: # &#123;% image %&#125; image: fancybox: true 1.18.5 支持解析原生 MD 语法 blog/_config.stellar.yml1234tag_plugins: image: replace_original: #把markdown格式的图片解析成图片标签 enable: true quot 引用 适合居中且醒目的引用：Stellar 是最好用的主题 支持自定义引号：热门话题 其中自定义引号素材在主题配置文件的 tag_plugins.quot 中配置： 123456789tag_plugins: ... # &#123;% quot %&#125; quot: default: # 可以自行配置多种图标方案 prefix: https://bu.dusays.com/2022/10/24/63567d3e092ff.png suffix: https://bu.dusays.com/2022/10/24/63567d3e0ab55.png hashtag: prefix: https://bu.dusays.com/2022/10/24/63567d3e07da3.png 写法如下12适合居中且醒目的引用：&#123;% quot Stellar 是最好用的主题 %&#125;支持自定义引号：&#123;% quot 热门话题 icon:hashtag %&#125; 特别引用 此外，加上 el:h2/h3/h4/h5/h6 可以作为标题使用 poetry 诗词 示例写法游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。诗词节选123456&#123;% poetry 游山西村 author:陆游 footer:诗词节选 %&#125;莫笑农家腊酒浑，丰年留客足鸡豚。**山重水复疑无路，柳暗花明又一村。**箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。&#123;% endpoetry %&#125; note 备注块 示例写法1&#123;% note [title] content [color:color] %&#125;123title: 标题（可选）content: 内容color: red/orange/yellow/green/cyan/blue/purple/light/dark/warning/error 具有标题的备注块 直接写备注内容，默认是和代码块一样的样式，第一个空格前面的是标题，后面的是正文，如果标题中需要显示空格，请使用 &amp;nbsp; 代替。 示例写法这&nbsp;是标题这是正文 哈哈。1&#123;% note 这&amp;nbsp;是标题 这是正文 哈哈。 %&#125; 彩色备注块 示例写法一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 一共支持12种颜色，可以满足几乎所有的需求了。color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。12&#123;% note 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125;&#123;% note color:cyan 一共支持12种颜色，可以满足几乎所有的需求了。 color 可设置 red、orange、yellow、green、cyan、blue、purple、light、dark、warning、error 几种取值。 %&#125; okr 目标管理 这是一个 OKR（Objectives and Key Results）示例： O1 2024年的小目标：完成 Volantis 6.0 并发布上线 来自2025年的复盘：已《基本》实现目标 正常 44% KR1 重构 tag-plugins 和 wiki 系统 当 KR 进度为 100% 时，标签默认显示为 已完成当 KR 未设置进度时，默认为 0%当 O 未设置进度时，则显示所有 KR 进度平均值 已完成 100% KR2 完成主要页面设计稿 小提示1小提示2您可以在 _config.yml 文件中修改标签的颜色和文案您可以在 _config.yml 文件中增加任意的标签配置 延期 90% KR3 完成前置准备工作（如果你知道答案，请在留言区帮帮我！🥹） 在咸水和海滩之间找一亩地求出圆周率后15位找出宇宙的终极逻辑去地狱里走两步 未完成 -12% KR-4 开发、测试和发布 支持嵌套插入图片等其它简单组件 风险 0% link 链接卡片 效果演示语法格式写法示例https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/ https://xaoxuu.com/blog/20221029/https://xaoxuu.com/blog/20221029/外链卡片标签的语法格式为： 1&#123;% link href [title] [icon:src] [desc:true/false] %&#125; 参数含义： 1234href: 链接title: 可选，手动设置标题（为空时会自动抓取页面标题）icon: 可选，手动设置图标（为空时会自动抓取页面图标）desc: 可选，是否显示摘要描述，为true时将会显示页面描述1234不带摘要的样式：&#123;% link https://xaoxuu.com/blog/20221029/ %&#125;带摘要的样式：&#123;% link https://xaoxuu.com/blog/20221029/ desc:true %&#125; mermaid 图表 安装插件 blog/_config.stellar.yml1234567mermaid: enable: false # js: https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js js: https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js # Available themes: default | dark | forest | neutral # 推荐使用 dark 主题 在夜间模式下显示效果更好 theme: dark 使用前需要在 Markdown 文件开头加入 123---mermaid: true--- 演示效果代码示例graph LR&#13; A(Section A) -->|option 1| B(Section A)&#13; B -->|option 2| C(Section C) gitGraph&#13; commit&#13; commit&#13; branch develop&#13; commit&#13; commit&#13; commit&#13; checkout main&#13; commit&#13; commit https://mermaid.js.org/intro/https://mermaid.js.org/intro/ copy 复制行 示例写法对于单行内容，可以使用 copy 标签来实现复制功能： 您可以设置 git:https 或者 git:ssh 或者 git:gh 来快速放置一个 git 仓库链接： 12345&#123;% copy curl -s https://sh.xaox.cc/install | sh %&#125;&#123;% copy width:max curl -s https://sh.xaox.cc/install | sh %&#125;&#123;% copy git:https xaoxuu.com/hexo-theme-stellar %&#125;&#123;% copy git:ssh xaoxuu.com/hexo-theme-stellar %&#125;&#123;% copy git:gh xaoxuu.com/hexo-theme-stellar %&#125; radio 单选 示例写法没有勾选的单选框 已勾选的单选框12&#123;% radio 没有勾选的单选框 %&#125;&#123;% radio checked:true 已勾选的单选框 %&#125; 支持的参数12checked: true/falsecolor: red/orange/yellow/green/cyan/blue/purple checkbox 复选 示例写法普通的没有勾选的复选框 普通的已勾选的复选框 显示为加号的绿色的已勾选的复选框 显示为减号的黄色的已勾选的复选框 显示为乘号的红色的已勾选的复选框12345&#123;% checkbox 普通的没有勾选的复选框 %&#125;&#123;% checkbox checked:true 普通的已勾选的复选框 %&#125;&#123;% checkbox symbol:plus color:green checked:true 显示为加号的绿色的已勾选的复选框 %&#125;&#123;% checkbox symbol:minus color:yellow checked:true 显示为减号的黄色的已勾选的复选框 %&#125;&#123;% checkbox symbol:times color:red checked:true 显示为乘号的红色的已勾选的复选框 %&#125; 支持的参数123checked: true/falsecolor: red/orange/yellow/green/cyan/blue/purplesymbol: plus/minus/times navbar 导航栏 文章内也可以插入一个导航栏： 1&#123;% navbar active:1 [文章](/) [项目](/wiki/) [留言](#comments) [GitHub](https://github.com/xaoxuu/) %&#125; 文章项目留言GitHub frame 设备框架 示例写法1&#123;% frame iphone11 img:/assets/wiki/prohud/toast/demo-loading.png video:/assets/wiki/prohud/toast/demo-loading.mp4 focus:top %&#125; 文本修饰标签集 这是 密码 标签 这是 下划线 标签 这是 着重号 标签 这是 波浪线 标签 这是 删除线 标签 这是 上角标 标签 这是 下角标 标签 这是 键盘样式 标签，试一试：⌘ + D 写法如下12345678- 这是 &#123;% psw 密码 %&#125; 标签- 这是 &#123;% u 下划线 %&#125; 标签- 这是 &#123;% emp 着重号 %&#125; 标签- 这是 &#123;% wavy 波浪线 %&#125; 标签- 这是 &#123;% del 删除线 %&#125; 标签- 这是 &#123;% sup 上角标 color:red %&#125; 标签- 这是 &#123;% sub 下角标 %&#125; 标签- 这是 &#123;% kbd 键盘样式 %&#125; 标签，试一试：&#123;% kbd ⌘ %&#125; + &#123;% kbd D %&#125;"},{"title":"使用标签插件增强阅读体验","date":"2024-03-25T16:11:03.186Z","updated":"2024-03-25T16:11:03.186Z","comments":true,"path":"wiki/stellar/tag-plugins/index.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/tag-plugins/","excerpt":"","text":"Stellar 的标签插件和 Hexo 官方的标签插件一样使用空格分隔多个参数，所以如果参数内容中需要出现的空格被意外分隔开了的时候，请使用 &amp;nbsp; 代替。为了方便理解，本文档语法格式中的可选参数用方括号括起来，键值对参数用冒号分隔开，例如： 1&#123;% image src [description] [download:bool/string] %&#125; 就表明第一个参数是图片链接，第二个参数是图片描述，而 download 是可选参数，并且值是布尔或字符串类型，第二三个参数为可选参数。 了解参数解析规则以图片标签为例，使用空格分隔开之后得到一个数组，如果图片描述文字中有空格，多分出来的这些「参数」被合并到最后一个「非键值对参数」中，什么是「非键值对参数」呢？举个例子您就明白了：1&#123;% image /assets/wiki/stellar/photos/183e71e0ad995.jpg 来自印度的 Rohit Vohra 使用 iPhone 12 Pro Max 拍摄。 download:https://www.apple.com.cn/newsroom/images/product/iphone/lifestyle/Apple_ShotoniPhone-rohit_vohra_12172020.zip %&#125;这个例子中，download:https://xxxx 是有冒号分隔开的，download 为键，后面的网址为值，所以叫做「键值对参数」；与此相对的，没有冒号分隔的就叫做「非键值对参数」。键值对参数可以放在任何位置，我可以通过匹配键来解析，而非键值对参数则只能通过顺序解析，所以它们必须和文档中要求的前后顺序一致。一般核心的、重要的参数会设置成非键值对参数，而可选参数设置成键值对参数。"},{"title":"阅读类标签（3个）","date":"2024-05-09T16:22:08.596Z","updated":"2024-05-09T16:22:08.596Z","comments":true,"path":"wiki/stellar/tag-plugins/read.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/tag-plugins/read.html","excerpt":"","text":"reel卷轴标签 一首诗 游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。2023.09.08诗词节选 莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。 EnglishTest且听风吟There is the website of 且听风吟, and it’s so wonderful!君亲启 与grid结合使用 游山西村陆游莫笑农家腊酒浑，丰年留客足鸡豚。山重水复疑无路，柳暗花明又一村。箫鼓追随春社近，衣冠简朴古风存。从今若许闲乘月，拄杖无时夜叩门。2023.09.08诗词节选EnglishTest且听风吟There is the website of 且听风吟, and it’s so wonderful!君亲启 paper纸张标签 单影只人见字如面。见字如面。心是一座孤岛，即便岛上繁花似锦，四季更替，依然只是一个人的风景。繁华也好，萧条也好，都只属于一个人。记得有人说过这样一句话：一人花开，一人花落，这些年从头到尾，无人问询。那种寥落，如轩窗外的一片月色，独自在树梢起舞，却无人欣赏它清丽的舞姿。又像是一阙小词，笔笔皆清冷，笔笔皆寂寥。抓到一名同学欢迎留言哦！好的，一定会的！且听风吟2023.09.08留言 单影只人心是一座孤岛，即便岛上繁花似锦，四季更替，依然只是一个人的风景。繁华也好，萧条也好，都只属于一个人。记得有人说过这样一句话：一人花开，一人花落，这些年从头到尾，无人问询。那种寥落，如轩窗外的一片月色，独自在树梢起舞，却无人欣赏它清丽的舞姿。又像是一阙小词，笔笔皆清冷，笔笔皆寂寥。且听风吟2023.09.08留言 英文标签 英文 YouthYouth is not a time of life; it is a state of mind; it is not a matter of rosy cheeks, red lips and supple knees; it is a matter of the will, a quality of the imagination, a vigor of the emotions; it is the freshness of the deep springs of life.Youth means a temperamental predominance of courage over timidity, of the appetite for adventure over the love of ease. This often exists in a man of 60 more than a boy of 20. Nobody grows old merely by a number of years. We grow old by deserting our ideals.Years may wrinkle the skin, but to give up enthusiasm wrinkles the soul. Worry, fear, self-distrust bows the heart and turns the spirit back to dust.Whether 60 or 16, there is in every human being’s heart the lure of wonders, the unfailing appetite for what’s next and the joy of the game of living. In the center of your heart and my heart, there is a wireless station; so long as it receives messages of beauty, hope, courage and power from man and from the infinite, so long as you are young.When your aerials are down, and your spirit is covered with snows of cynicism and the ice of pessimism, then you’ve grown old, even at 20; but as long as your aerials are up, to catch waves of optimism, there’s hope you may die young at 80.且听风吟2023.12.27英文测试 译文 青春青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志，恢宏的想象，炙热的恋情；青春是生命的深泉在涌流。青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生而有之，六旬男子则更多见。年岁有加，并非垂老，理想丢弃，方堕暮年。岁月悠悠，衰微只及肌肤；热忱抛却，颓废必致灵魂。忧烦，惶恐，丧失自信，定使心灵扭曲，意气如灰。无论年届花甲，拟或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。一旦天线下降，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即使年方二十，实已垂垂老矣；然则只要树起天线，捕捉乐观信号，你就有望在八十高龄告别尘寰时仍觉年轻。且听风吟2023.12.27英文翻译"},{"title":"时间线测试（临时）","date":"2024-03-25T16:11:03.206Z","updated":"2024-03-25T16:11:03.206Z","comments":true,"path":"wiki/stellar/tag-plugins/timeline.html","permalink":"https://stellar.listentothewind.cn/wiki/stellar/tag-plugins/timeline.html","excerpt":"","text":"原版汉化版 v16512345"}],"posts":[{"title":"博客测试","slug":"blog/2023-09-22-测试","date":"2024-03-25T16:10:58.583Z","updated":"2024-03-25T16:10:58.583Z","comments":true,"path":"blog/2023-09-22-测试/","permalink":"https://stellar.listentothewind.cn/blog/2023-09-22-%E6%B5%8B%E8%AF%95/","excerpt":"这是一个博客测试文档。","text":"这是一个博客测试文档。 测试 这是一个博客测试文档。 测试测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; title: &#123; text: &#x27;Stacked Line&#x27; &#125;, tooltip: &#123; trigger: &#x27;axis&#x27; &#125;, legend: &#123; data: [&#x27;Email&#x27;, &#x27;Union Ads&#x27;, &#x27;Video Ads&#x27;, &#x27;Direct&#x27;, &#x27;Search Engine&#x27;] &#125;, grid: &#123; left: &#x27;3%&#x27;, right: &#x27;4%&#x27;, bottom: &#x27;3%&#x27;, containLabel: true &#125;, toolbox: &#123; feature: &#123; saveAsImage: &#123;&#125; &#125; &#125;, xAxis: &#123; type: &#x27;category&#x27;, boundaryGap: false, data: [&#x27;Mon&#x27;, &#x27;Tue&#x27;, &#x27;Wed&#x27;, &#x27;Thu&#x27;, &#x27;Fri&#x27;, &#x27;Sat&#x27;, &#x27;Sun&#x27;] &#125;, yAxis: &#123; type: &#x27;value&#x27; &#125;, series: [ &#123; name: &#x27;Email&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [120, 132, 101, 134, 90, 230, 210] &#125;, &#123; name: &#x27;Union Ads&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [220, 182, 191, 234, 290, 330, 310] &#125;, &#123; name: &#x27;Video Ads&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [150, 232, 201, 154, 190, 330, 410] &#125;, &#123; name: &#x27;Direct&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [320, 332, 301, 334, 390, 330, 320] &#125;, &#123; name: &#x27;Search Engine&#x27;, type: &#x27;line&#x27;, stack: &#x27;Total&#x27;, data: [820, 932, 901, 934, 1290, 1330, 1320] &#125; ], sdgfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&#125; 测试-3 测试-3 测试-4 测试-5 测试-6 测试-4 测试-5 树形结构 一颗二叉树ABDECFG这是一颗二叉树，先序遍历为：ABDECFG，中序遍历为：DBEAFCG，后序遍历为：DEBFGCA，层序遍历为：ABCDEFG。 github issue测试 errors array[object] Required code integer Required &gt;= 1000 &gt; This line &lt; message string Required messages array[string] Required result object or null Required Allowed values: null success boolean Required Whether the API call was successful Allowed value: false Example: false chat 14:36 24 这是一个群聊 2024年5月22日 21:43群主Hc你好管理员customAre U OK群主Hc群主Hc管理员custom群主Hc https://xaoxuu.com/blog/20221029/ https://xaoxuu.com/blog/20221029/ 发送","categories":[{"name":"测试","slug":"测试","permalink":"https://stellar.listentothewind.cn/blog/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://stellar.listentothewind.cn/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"测试","slug":"测试","permalink":"https://stellar.listentothewind.cn/blog/tags/%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"测试","slug":"测试","permalink":"https://stellar.listentothewind.cn/blog/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://stellar.listentothewind.cn/blog/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"测试","slug":"测试","permalink":"https://stellar.listentothewind.cn/blog/tags/%E6%B5%8B%E8%AF%95/"}]}